<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Openwrt学习笔记11_20 | 我的世界</title><meta name="keywords" content="openwrt,linux"><meta name="author" content="NPCS_AS"><meta name="copyright" content="NPCS_AS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="cungudafa:在学习中">
<meta property="og:type" content="article">
<meta property="og:title" content="Openwrt学习笔记11_20">
<meta property="og:url" content="https://alongsoft2018.github.io.git/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/index.html">
<meta property="og:site_name" content="我的世界">
<meta property="og:description" content="cungudafa:在学习中">
<meta property="og:locale">
<meta property="og:image" content="https://openwrt.org/_media/logo.png">
<meta property="article:published_time" content="2021-08-17T17:36:22.000Z">
<meta property="article:modified_time" content="2021-08-17T17:40:41.607Z">
<meta property="article:author" content="NPCS_AS">
<meta property="article:tag" content="openwrt">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://openwrt.org/_media/logo.png"><link rel="shortcut icon" href="/img/npcs.jpeg"><link rel="canonical" href="https://alongsoft2018.github.io.git/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Openwrt学习笔记11_20',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-18 01:40:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="我的世界" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar_max.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://openwrt.org/_media/logo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">我的世界</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Openwrt学习笔记11_20</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-17T17:36:22.000Z" title="Created 2021-08-18 01:36:22">2021-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-08-17T17:40:41.607Z" title="Updated 2021-08-18 01:40:41">2021-08-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Openwrt学习笔记11_20"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[toc]</p>
<h1 id="十一、UCI"><a href="#十一、UCI" class="headerlink" title="十一、UCI"></a>十一、UCI</h1><p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/techref/uci">https://openwrt.org/docs/techref/uci</a></p>
<p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-user/base-system/notuci.config">https://openwrt.org/docs/guide-user/base-system/notuci.config</a></p>
<p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-user/base-system/uci">https://openwrt.org/docs/guide-user/base-system/uci</a><br><img src="https://img-blog.csdnimg.cn/2021071310502682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713110735399.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713110815524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713110838330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713110911292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713111526437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713110956508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br>Perl/Python/Php（配置脚本语言需要解析器） </p>
<p>Json/xml/TP/net core</p>
<p>shell 石像鬼</p>
<p>luna： luci</p>
<p>uci：配置文件格式</p>
<p>network json/xml push 到前台</p>
<p>shell/c 绑定</p>
<h1 id="十二、OpenWRT启动过程分析"><a href="#十二、OpenWRT启动过程分析" class="headerlink" title="十二、OpenWRT启动过程分析"></a>十二、OpenWRT启动过程分析</h1><hr>
<p>CPU上电 — bootloader — kernel — init（openWRT）</p>
<p>kernel: unix,linux,bsd,ecos…</p>
<p>OpenWRT/LEDE: System Boot Sequence</p>
<p><a target="_blank" rel="noopener" href="https://oldwiki.archive.openwrt.org/doc/techref/process.boot">https://oldwiki.archive.openwrt.org/doc/techref/process.boot</a></p>
<p><a target="_blank" rel="noopener" href="https://oldwiki.archive.openwrt.org/doc/techref/init.detail.cc">https://oldwiki.archive.openwrt.org/doc/techref/init.detail.cc</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002392043">https://segmentfault.com/a/1190000002392043</a></p>
<p><a target="_blank" rel="noopener" href="https://clockworkbird9.wordpress.com/2016/09/29/openwrtlede-system-boot-sequence/">https://clockworkbird9.wordpress.com/2016/09/29/openwrtlede-system-boot-sequence/</a></p>
<p><a target="_blank" rel="noopener" href="http://wiki.dreamrunner.org/public_html/Communication/OpenWrt/OpenWrtBootProcess-NewOpenWrt.html">http://wiki.dreamrunner.org/public_html/Communication/OpenWrt/OpenWrtBootProcess-NewOpenWrt.html</a></p>
<ul>
<li>OpenWrt Boot Process (New OpenWrt)</li>
<li>Table of Contents<blockquote>
<ul>
<li>一个boot log的例子:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    2.602573] VFS: Mounted root (squashfs filesystem) readonly on device 31:2.</span><br><span class="line">[    2.610535] Freeing unused kernel memory: 224K (80428000 - 80460000)</span><br><span class="line">[    3.912151] init: Console is alive</span><br><span class="line">[    3.916056] init: - watchdog -</span><br><span class="line">[    6.994992] init: - preinit -</span><br><span class="line">Press the [f] key and hit [enter] to enter failsafe mode</span><br><span class="line">Press the [1], [2], [3] or [4] key and hit [enter] to select the debug level</span><br><span class="line">Before mount_root</span><br><span class="line">[   10.352510] jffs2: notice: (401) jffs2_build_xattr_subsystem: complete building xattr subsystem, 0 of xdatum (0 unchecked, 0 orphan) and 0 of xref (0 dead, 0 orphan) found.</span><br><span class="line">[   10.369525] mount_root: switching to jffs2 overlay</span><br><span class="line">[   10.540372] procd: - early -</span><br><span class="line">[   10.543495] procd: - watchdog -</span><br><span class="line">[   11.303217] procd: - ubus -</span><br><span class="line">[   12.307928] random: ubusd: uninitialized urandom read (4 bytes read, 53 bits of entropy available)</span><br><span class="line">[   12.439119] procd: - init -</span><br><span class="line">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li><ol>
<li>Boot<ul>
<li>1). <strong>Bootloader 比如U-Boot, 配置底层硬件,加载Linux kernel 和 device tree blob, 最后传入kernel cmdline跳转到Linux kernel image.</strong></li>
<li>2). <strong>高通的Secure boot会复杂点,先PBL(Primary Boot Loader), 然后 SBL1(Second BootLoader stage 1) 初始化buses、DDR、clocks等, SBL1 移交运行控制权给QSEE。QSEE建立安全运行环境，配置xPU，支持fuse, 之后才转入APPSBL即为BootLoader, 跳转到HLOS(High LevelOperating System) 即为Linux kernel.</strong></li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>Kernel init Hareware<br>Linux Kernel 将继续初始化外围硬件.</li>
</ol>
</li>
<li><ol>
<li>Kernel -&gt; Filesystem<br>Mount the root filesystem (通过kernel cmdline中的诸如参数 root=, rootfstype=).</li>
</ol>
</li>
<li><ol>
<li>Kernel -&gt; Init Process<br>最后kernel启动 init 进程 (PID 1).</li>
</ol>
</li>
<li><ol>
<li>Run preinit<br>再procd接管前, preinit会对系统做一些前期的初始工作.</li>
</ol>
</li>
<li><ol>
<li>Run procd<br>一旦preinit完成,它将exec procd. 这将用procd取代原来pid1的init进程. watchdog的file descriptor不会被关闭, 而是传入到procd进程.</li>
</ol>
</li>
</ul>
<p>OpenWrt系统从第4步开始. 在OpenWrt系统中, 这个init初始化进程不是普通 Linux中一个初始进程, 而是专为OpenWrt写的一个shell脚本.</p>
<h2 id="preinit"><a href="#preinit" class="headerlink" title="preinit"></a>preinit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/preinit</span><br></pre></td></tr></table></figure>
<p>无论Linux什么版本, OpenWrt都会有类似如下的patch,把OpenWrt的init进程放在第一个位置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- a/init/main.c</span><br><span class="line">+++ b/init/main.c</span><br><span class="line">@@ -963,7 +963,8 @@ static int __ref kernel_init(void *unuse</span><br><span class="line">                pr_err(&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;,</span><br><span class="line">                        execute_command, ret);</span><br><span class="line">        &#125;</span><br><span class="line">-       if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">+       if (!try_to_run_init_process(&quot;/etc/preinit&quot;) ||</span><br><span class="line">+           !try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">            !try_to_run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">            !try_to_run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">            !try_to_run_init_process(&quot;/bin/sh&quot;))</span><br></pre></td></tr></table></figure>
<p>/etc/preinit 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Copyright (C) 2006 OpenWrt.org</span><br><span class="line"># Copyright (C) 2010 Vertical Communications</span><br><span class="line"> </span><br><span class="line">[ -z &quot;$PREINIT&quot; ] &amp;&amp; exec /sbin/init</span><br><span class="line"> </span><br><span class="line">export PATH=/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"> </span><br><span class="line">pi_ifname=</span><br><span class="line">pi_ip=192.168.1.1</span><br><span class="line">pi_broadcast=192.168.1.255</span><br><span class="line">pi_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_ifname=</span><br><span class="line">fs_failsafe_ip=192.168.1.1</span><br><span class="line">fs_failsafe_broadcast=192.168.1.255</span><br><span class="line">fs_failsafe_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_wait_timeout=0</span><br><span class="line"> </span><br><span class="line">pi_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_path=&quot;/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">pi_init_cmd=&quot;/sbin/init&quot;</span><br><span class="line"> </span><br><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br><span class="line"> </span><br><span class="line">boot_hook_init preinit_essential</span><br><span class="line">boot_hook_init preinit_main</span><br><span class="line">boot_hook_init failsafe</span><br><span class="line">boot_hook_init initramfs</span><br><span class="line">boot_hook_init preinit_mount_root</span><br><span class="line"> </span><br><span class="line">for pi_source_file in /lib/preinit/*; do</span><br><span class="line">        . $pi_source_file</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">boot_run_hook preinit_essential</span><br><span class="line"> </span><br><span class="line">pi_mount_skip_next=false</span><br><span class="line">pi_jffs2_mount_success=false</span><br><span class="line">pi_failsafe_net_message=false</span><br><span class="line"> </span><br><span class="line">boot_run_hook preinit_main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里第一行命令是:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ -z &quot;$PREINIT&quot; ] &amp;&amp; exec /sbin/init</span><br></pre></td></tr></table></figure><br>PREINIT 还没有define, 所以执行 /sbin/init. 这个程序来自package procd.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/init</span><br></pre></td></tr></table></figure></p>
<ul>
<li>package procd中 init.c 的main函数基本流程如下:1<br><img src="https://img-blog.csdnimg.cn/img_convert/3e7863390805a93a4fdf4a7607b42d34.png" alt="image"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. early()</span><br><span class="line">early_mounts(): mount /proc /sys/&#123;,fs/cgroup&#125; /dev/&#123;,shm,pts&#125; 等;</span><br><span class="line">early_console(): 初始化 /dev/console;</span><br><span class="line">early_env();: PATH 配置成 /bin:/sbin:/usr/bin:/usr/sbin;</span><br><span class="line">打印出最上面bootlog实例中的一个message &quot;Console is alive&quot;;</span><br><span class="line">2. cmdline(): get_cmdline_val(&quot;init_debug&quot;, line, sizeof(line)); 从 /proc/cmdline 中读取kernel boot commands,并解析出 init_debug 的值</span><br><span class="line">3. watchdog_init(1): 先从env的 WDTFD 中获取watchdog的fd,若不存在, 就尝试打开 /dev/watchdog. 并初始化watchdog, 最后打印出最上面 bootlog实例中的message &quot;- watchdog -&quot;</span><br><span class="line">4. fork 一个新的进程来让 /sbin/kmodloader 从 /etc/modules-boot.d/ 加载device drivers (注意,这里加载的是boot期间的drivers而不是 /etc/modules.d/)</span><br><span class="line">5. uloop_init() 初始化uloop (event loop implementation, 来自package libubox). 之后procd和 sh /etc/preinit 将由uloop管理;</span><br><span class="line">6. preinit()</span><br><span class="line">打印最上面的第三条信息 &quot;- preinit -&quot;</span><br><span class="line">fork一个新的进程执行 /sbin/procd -h /etc/hotplug-preinit.json, 并在完后执行一个callback function plugd_proc_cb (仅仅做了 proc-&gt;pid = 0; )</span><br><span class="line">setenv(&quot;PREINIT&quot;, &quot;1&quot;, 1);</span><br><span class="line">fork一个新的进程执行 sh /etc/preinit , 并在完后执行一个callback function spawn_procd, spawn_procd 将wdtfd设置到env中的WDTFD, 从 /tmp/debuglevel 读取的 debug level设置到env中的DBGLVL. 最后 fork一个新进程执行 /sbin/procd</span><br><span class="line">7. uloop_run(): 最后由uloop接管</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="再次执行-etc-preinit"><a href="#再次执行-etc-preinit" class="headerlink" title="再次执行 /etc/preinit"></a>再次执行 /etc/preinit</h2><p>init进程再次执行 /etc/preinit, 第一部分如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"> </span><br><span class="line">pi_ifname=</span><br><span class="line">pi_ip=192.168.1.1</span><br><span class="line">pi_broadcast=192.168.1.255</span><br><span class="line">pi_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_ifname=</span><br><span class="line">fs_failsafe_ip=192.168.1.1</span><br><span class="line">fs_failsafe_broadcast=192.168.1.255</span><br><span class="line">fs_failsafe_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_wait_timeout=0</span><br><span class="line"> </span><br><span class="line">pi_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_path=&quot;/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">pi_init_cmd=&quot;/sbin/init&quot;</span><br></pre></td></tr></table></figure>
<p>如上仅仅定义些变量.</p>
<p>从如下地方定义一些函数:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br></pre></td></tr></table></figure></p>
<p>定义在 /lib/functions/preinit.sh 中的 boot_hook_init 被用来初始化如下hook<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boot_hook_init preinit_essential</span><br><span class="line">boot_hook_init preinit_main</span><br><span class="line">boot_hook_init failsafe</span><br><span class="line">boot_hook_init initramfs</span><br><span class="line">boot_hook_init preinit_mount_root</span><br></pre></td></tr></table></figure><br>/lib/preinit/ 下的脚本都被执行. 这些脚本主要通过 boot_hook_add 来添加各个hook函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for pi_source_file in /lib/preinit/*; do</span><br><span class="line">        . $pi_source_file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>最后分别执行 preinit_essential 和 preinit_main 中的hook函数.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boot_run_hook preinit_essential</span><br><span class="line">boot_run_hook preinit_main</span><br></pre></td></tr></table></figure></p>
<h2 id="procd"><a href="#procd" class="headerlink" title="procd"></a>procd</h2><p>OpenWrt使用 procd 来启动系统,管理进程和处理部分kernel与用户层的交互.</p>
<p>procd 首先做一些初始化工作, setsid(); 设置自己成为进程组的所有者, uloop_init(); 为后续 uloop_run 做初始化, procd_signal(); 设置好 signals.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void procd_signal(void)</span><br><span class="line">&#123;</span><br><span class="line">        signal(SIGPIPE, SIG_IGN);</span><br><span class="line">        if (getpid() != 1)</span><br><span class="line">                return;</span><br><span class="line">        sigaction(SIGTERM, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGINT, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGUSR1, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGUSR2, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGSEGV, &amp;sa_crash, NULL);</span><br><span class="line">        sigaction(SIGBUS, &amp;sa_crash, NULL);</span><br><span class="line">        sigaction(SIGHUP, &amp;sa_dummy, NULL);</span><br><span class="line">        sigaction(SIGKILL, &amp;sa_dummy, NULL);</span><br><span class="line">        sigaction(SIGSTOP, &amp;sa_dummy, NULL);</span><br><span class="line">        reboot(RB_DISABLE_CAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>procd 共有6个状态, STATE_EARLY, STATE_UBUS, STATE_INIT, STATE_RUNNING, STATE_SHUTDOWN 和 STATE_HALT, procd 的状态从第一个直到最后一个.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void state_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">        char ubus_cmd[] = &quot;/sbin/ubusd&quot;;</span><br><span class="line"> </span><br><span class="line">        switch (state) &#123;</span><br><span class="line">        case STATE_EARLY:</span><br><span class="line">                LOG(&quot;- early -\n&quot;);</span><br><span class="line">                watchdog_init(0);</span><br><span class="line">                hotplug(&quot;/etc/hotplug.json&quot;);</span><br><span class="line">                procd_coldplug();</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        case STATE_UBUS:</span><br><span class="line">                // try to reopen incase the wdt was not available before coldplug</span><br><span class="line">                watchdog_init(0);</span><br><span class="line">                set_stdio(&quot;console&quot;);</span><br><span class="line">                LOG(&quot;- ubus -\n&quot;);</span><br><span class="line">                procd_connect_ubus();</span><br><span class="line">                service_init();</span><br><span class="line">                service_start_early(&quot;ubus&quot;, ubus_cmd);</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        case STATE_INIT:</span><br><span class="line">                LOG(&quot;- init -\n&quot;);</span><br><span class="line">                procd_inittab();</span><br><span class="line">                procd_inittab_run(&quot;respawn&quot;);</span><br><span class="line">                procd_inittab_run(&quot;askconsole&quot;);</span><br><span class="line">                procd_inittab_run(&quot;askfirst&quot;);</span><br><span class="line">                procd_inittab_run(&quot;sysinit&quot;);</span><br><span class="line"> </span><br><span class="line">                // switch to syslog log channel</span><br><span class="line">                ulog_open(ULOG_SYSLOG, LOG_DAEMON, &quot;procd&quot;);</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        case STATE_RUNNING:</span><br><span class="line">                LOG(&quot;- init complete -\n&quot;);</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        case STATE_SHUTDOWN:</span><br><span class="line">                /* Redirect output to the console for the users&#x27; benefit */</span><br><span class="line">                set_console();</span><br><span class="line">                LOG(&quot;- shutdown -\n&quot;);</span><br><span class="line">                procd_inittab_run(&quot;shutdown&quot;);</span><br><span class="line">                sync();</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        case STATE_HALT:</span><br><span class="line">                // To prevent killed processes from interrupting the sleep</span><br><span class="line">                signal(SIGCHLD, SIG_IGN);</span><br><span class="line">                LOG(&quot;- SIGTERM processes -\n&quot;);</span><br><span class="line">                kill(-1, SIGTERM);</span><br><span class="line">                sync();</span><br><span class="line">                sleep(1);</span><br><span class="line">                LOG(&quot;- SIGKILL processes -\n&quot;);</span><br><span class="line">                kill(-1, SIGKILL);</span><br><span class="line">                sync();</span><br><span class="line">                sleep(1);</span><br><span class="line">                if (reboot_event == RB_POWER_OFF)</span><br><span class="line">                        LOG(&quot;- power down -\n&quot;);</span><br><span class="line">                else</span><br><span class="line">                        LOG(&quot;- reboot -\n&quot;);</span><br><span class="line"> </span><br><span class="line">                /* Allow time for last message to reach serial console, etc */</span><br><span class="line">                sleep(1);</span><br><span class="line"> </span><br><span class="line">                /* We have to fork here, since the kernel calls do_exit(EXIT_SUCCESS)</span><br><span class="line">                 * in linux/kernel/sys.c, which can cause the machine to panic when</span><br><span class="line">                 * the init process exits... */</span><br><span class="line">                if (!vfork( )) &#123; /* child */</span><br><span class="line">                        reboot(reboot_event);</span><br><span class="line">                        _exit(EXIT_SUCCESS);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                while (1)</span><br><span class="line">                        sleep(1);</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">        default:</span><br><span class="line">                ERROR(&quot;Unhandled state %d\n&quot;, state);</span><br><span class="line">                return;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STATE-EARLY"><a href="#STATE-EARLY" class="headerlink" title="STATE_EARLY"></a>STATE_EARLY</h2><ul>
<li>watchdog_init(0); 初始化watchdog;</li>
<li>hotplug(“/etc/hotplug.json”); 将根据 /etc/hotplug.json 中定义的规则来监视hotplug event;</li>
<li>procd_coldplug(); 重新mount /dev , fork新进程来运行 * udevtrigger, 它将产生coldplug events来让hotplug监视;</li>
<li>当 =udevtrigger 完成, callback函数 udevtrigger_complete 中最后将调用 procd_state_next() 来使得状态从 STATE_EARLY 到 STATE_UBUS.;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void coldplug_complete(struct uloop_timeout *t)</span><br><span class="line">&#123;</span><br><span class="line">        DEBUG(4, &quot;Coldplug complete\n&quot;);</span><br><span class="line">        hotplug_last_event(NULL);</span><br><span class="line">        procd_state_next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STATE-UBUS"><a href="#STATE-UBUS" class="headerlink" title="STATE_UBUS"></a>STATE_UBUS</h2></li>
</ul>
<ol>
<li>watchdog_init(0); 再次初始化watchdog, 防止在coldplug之前watchdog不可用;</li>
<li>set_stdio(“console”); 设置stdin/out/err 到 /dev/console;</li>
<li>procd_connect_ubus(); 定义一个定时器不断去connect ubusd 即使这里 ubusd 还没创建好. 当 procd 之后连上 ubusd, 它将注册services, main_objec, system_object 和 watch_event .;</li>
<li>ubus_connect(ubus_socket); 这里用的是 /var/run/ubus.sock（UBUS_UNIX_SOCKET), 连上ubus后, procd_state_ubus_connect() 进入 STATE_INIT;</li>
<li>service_init(); 为之后services和validators的管理初始化ALV tree;</li>
<li>service_start_early(“ubus”, ubus_cmd); 开始 ubusd 后台服务;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">ubus_connect_cb(struct uloop_timeout *timeout)</span><br><span class="line">&#123;</span><br><span class="line">        ctx = ubus_connect(ubus_socket);</span><br><span class="line"> </span><br><span class="line">        if (!ctx) &#123;</span><br><span class="line">                DEBUG(4, &quot;Connection to ubus failed\n&quot;);</span><br><span class="line">                uloop_timeout_set(&amp;ubus_timer, 1000);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ctx-&gt;connection_lost = ubus_disconnect_cb;</span><br><span class="line">        ubus_init_service(ctx);</span><br><span class="line">        ubus_init_system(ctx);</span><br><span class="line">        watch_ubus(ctx);</span><br><span class="line"> </span><br><span class="line">        DEBUG(2, &quot;Connected to ubus, id=%08x\n&quot;, ctx-&gt;local_id);</span><br><span class="line">        ubus_add_uloop(ctx);</span><br><span class="line">        procd_state_ubus_connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STATE-INIT"><a href="#STATE-INIT" class="headerlink" title="STATE_INIT"></a>STATE_INIT</h2><ul>
<li>根据 handlers[] 中定义, procd在inittab中支持5个命令:<ul>
<li>respawn - this works just like you expect it. It starts a process and will respawn it once it has completed.</li>
<li>respawnlate - this works like the respawn but will start the process only when the procd init is completed.</li>
<li>askfirst - this works just like respawn but will print the line “Please press Enter to activate this console.” before starting the process</li>
<li>askconsole - this works like askfirst but, instead of running on the tty passed as a parameter, it will look for the tty defined in the kernel command line using “console=”</li>
<li>askconsolelate - this works like the askconsole but will start the process only when the procd init is completed.</li>
<li>sysinit - this will trigger procd to run the command, given as a parameter, only once. This is usually used to trigger execution of /etc/rc.d/</li>
<li>procd_inittab(); 读取 /etc/inittab , 初始化actions表</li>
<li>procd_inittab_run 依次run<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procd_inittab_run(&quot;respawn&quot;);</span><br><span class="line">procd_inittab_run(&quot;askconsole&quot;);</span><br><span class="line">procd_inittab_run(&quot;askfirst&quot;);</span><br><span class="line">procd_inittab_run(&quot;sysinit&quot;)</span><br></pre></td></tr></table></figure></li>
<li>procd_inittab_run 会与 /etc/inittab 创建的actions表对比, 只运行其中定义的<ul>
<li>askconsole –&gt; askfirst() 和 sysinit –&gt; runrc()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/etc/inittab</span><br><span class="line">::sysinit:/etc/init.d/rcS S boot</span><br><span class="line">::shutdown:/etc/init.d/rcS K shutdown</span><br><span class="line">::askconsole:/bin/ash --login</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct init_handler handlers[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;sysinit&quot;,</span><br><span class="line">                .cb = runrc,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;shutdown&quot;,</span><br><span class="line">                .cb = runrc,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;askfirst&quot;,</span><br><span class="line">                .cb = askfirst,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;askconsole&quot;,</span><br><span class="line">                .cb = askconsole,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;respawn&quot;,</span><br><span class="line">                .cb = rcrespawn,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static char *ask = &quot;/sbin/askfirst&quot;;</span><br><span class="line"> </span><br><span class="line">static void askconsole(struct init_action *a)</span><br><span class="line">&#123;</span><br><span class="line">        char line[256], *tty, *split;</span><br><span class="line">        int i;</span><br><span class="line"> </span><br><span class="line">        tty = get_cmdline_val(&quot;console&quot;, line, sizeof(line));</span><br><span class="line">        if (tty != NULL) &#123;</span><br><span class="line">                split = strchr(tty, &#x27;,&#x27;);</span><br><span class="line">                if (split != NULL)</span><br><span class="line">                        *split = &#x27;\0&#x27;;</span><br><span class="line"> </span><br><span class="line">                if (!dev_exist(tty)) &#123;</span><br><span class="line">                        DEBUG(4, &quot;skipping %s\n&quot;, tty);</span><br><span class="line">                        return;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                console = strdup(tty);</span><br><span class="line">                a-&gt;id = strdup(tty);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                console = NULL;</span><br><span class="line">                a-&gt;id = NULL;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        a-&gt;tout.cb = respawn;</span><br><span class="line">        for (i = MAX_ARGS - 1; i &gt;= 1; i--)</span><br><span class="line">                a-&gt;argv[i] = a-&gt;argv[i - 1];</span><br><span class="line">        a-&gt;argv[0] = ask;</span><br><span class="line">        a-&gt;respawn = 500;</span><br><span class="line"> </span><br><span class="line">        a-&gt;proc.cb = child_exit;</span><br><span class="line">        fork_worker(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void runrc(struct init_action *a)</span><br><span class="line">&#123;</span><br><span class="line">        if (!a-&gt;argv[1] || !a-&gt;argv[2]) &#123;</span><br><span class="line">                ERROR(&quot;valid format is rcS &lt;S|K&gt; &lt;param&gt;\n&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        /* proceed even if no init or shutdown scripts run */</span><br><span class="line">        if (rcS(a-&gt;argv[1], a-&gt;argv[2], rcdone))</span><br><span class="line">                rcdone(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STATE-RUNNING"><a href="#STATE-RUNNING" class="headerlink" title="STATE_RUNNING"></a>STATE_RUNNING</h2><p>基本的系统起来了, procd在 uloop_run() 中执行, 开始管理daemons和 services.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procd/initd/init.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">        pid_t pid;</span><br><span class="line"> </span><br><span class="line">        ulog_open(ULOG_KMSG, LOG_DAEMON, &quot;init&quot;);</span><br><span class="line"> </span><br><span class="line">        sigaction(SIGTERM, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGUSR1, &amp;sa_shutdown, NULL);</span><br><span class="line">        sigaction(SIGUSR2, &amp;sa_shutdown, NULL);</span><br><span class="line"> </span><br><span class="line">        early();</span><br><span class="line">        cmdline();</span><br><span class="line">        watchdog_init(1);</span><br><span class="line"> </span><br><span class="line">        pid = fork();</span><br><span class="line">        if (!pid) &#123;</span><br><span class="line">                char *kmod[] = &#123; &quot;/sbin/kmodloader&quot;, &quot;/etc/modules-boot.d/&quot;, NULL &#125;;</span><br><span class="line"> </span><br><span class="line">                if (debug &lt; 3) &#123;</span><br><span class="line">                        int fd = open(&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line"> </span><br><span class="line">                        if (fd &gt; -1) &#123;</span><br><span class="line">                                dup2(fd, STDIN_FILENO);</span><br><span class="line">                                dup2(fd, STDOUT_FILENO);</span><br><span class="line">                                dup2(fd, STDERR_FILENO);</span><br><span class="line">                                if (fd &gt; STDERR_FILENO)</span><br><span class="line">                                        close(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                execvp(kmod[0], kmod);</span><br><span class="line">                ERROR(&quot;Failed to start kmodloader\n&quot;);</span><br><span class="line">                exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid &lt;= 0) &#123;</span><br><span class="line">                ERROR(&quot;Failed to start kmodloader instance\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">                        if (waitpid(pid, NULL, WNOHANG) &gt; 0)</span><br><span class="line">                                break;</span><br><span class="line">                        sleep(1);</span><br><span class="line">                        watchdog_ping();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        uloop_init();</span><br><span class="line">        preinit();</span><br><span class="line">        uloop_run();</span><br><span class="line"> </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct init_handler handlers[]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct init_handler handlers[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;sysinit&quot;,</span><br><span class="line">                .cb = runrc,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;shutdown&quot;,</span><br><span class="line">                .cb = runrc,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;askfirst&quot;,</span><br><span class="line">                .cb = askfirst,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;askconsole&quot;,</span><br><span class="line">                .cb = askconsole,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                .name = &quot;respawn&quot;,</span><br><span class="line">                .cb = rcrespawn,</span><br><span class="line">                .multi = 1,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int rcS(char *pattern, char *param, void (*q_empty)(struct runqueue *))</span><br><span class="line">&#123;</span><br><span class="line">        runqueue_init(&amp;q);</span><br><span class="line">        q.empty_cb = q_empty;</span><br><span class="line">        q.max_running_tasks = 1;</span><br><span class="line"> </span><br><span class="line">        return _rc(&amp;q, &quot;/etc/rc.d&quot;, pattern, &quot;*&quot;, param);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int _rc(struct runqueue *q, char *path, const char *file, char *pattern, char *param)</span><br><span class="line">&#123;</span><br><span class="line">        char *dir = alloca(2 + strlen(path) + strlen(file) + strlen(pattern));</span><br><span class="line">        glob_t gl;</span><br><span class="line">        int j;</span><br><span class="line"> </span><br><span class="line">        if (!dir) &#123;</span><br><span class="line">                ERROR(&quot;Out of memory in %s.\n&quot;, file);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        DEBUG(2, &quot;running %s/%s%s %s\n&quot;, path, file, pattern, param);</span><br><span class="line">        sprintf(dir, &quot;%s/%s%s&quot;, path, file, pattern);</span><br><span class="line">        if (glob(dir, GLOB_NOESCAPE | GLOB_MARK, NULL, &amp;gl)) &#123;</span><br><span class="line">                DEBUG(2, &quot;glob failed on %s\n&quot;, dir);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        for (j = 0; j &lt; gl.gl_pathc; j++)</span><br><span class="line">                add_initd(q, gl.gl_pathv[j], param);</span><br><span class="line">        globfree(&amp;gl);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void rcdone(struct runqueue *q)</span><br><span class="line">&#123;</span><br><span class="line">        procd_state_next();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="OpenWRT-LEDE-System-Boot-Sequence"><a href="#OpenWRT-LEDE-System-Boot-Sequence" class="headerlink" title="OpenWRT/LEDE: System Boot Sequence"></a>OpenWRT/LEDE: System Boot Sequence</h2><p>Posted on 2016-09-29 by ClockworkBird</p>
<p>In this article I will try to summary and analyze the boot sequnece of OpenWRT system in details.</p>
<p>Hardware</p>
<p>ci40</p>
<p>Software</p>
<p>OpenWRT for ci40</p>
<p>You may find difference amound different OpenWRT version and LEDE. But I believe that it won’t affect the understanding.</p>
<p>Example boot log from ci40<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 2.824545] VFS: Mounted root (ext4 filesystem) readonly on device 179:1.</span><br><span class="line">[ 2.833446] Freeing unused kernel memory: 244K (84733000 - 84770000)</span><br><span class="line">[ 3.006884] init: Console is alive</span><br><span class="line">[ 3.011436] init: - watchdog -</span><br><span class="line">[ 3.329383] init: - preinit -</span><br><span class="line">[ 6.570976] mount_root: mounting /dev/root</span><br><span class="line">[ 6.579281] EXT4-fs (mmcblk0p1): re-mounted. Opts: (null)</span><br><span class="line">[ 6.596450] procd: - early -</span><br><span class="line">[ 6.599817] procd: - watchdog -</span><br><span class="line">[ 7.301153] procd: - ubus -</span><br><span class="line">[ 7.362047] procd: - init -</span><br></pre></td></tr></table></figure></p>
<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>The whole system boot process is firstly shown in a nutshell:</p>
<ul>
<li>Bootloader e.g., U-Boot:<br>It configures low level hardwares, loads Linux kernel imag and device tree blob, finally jumps to Linux kernel image in the RAM with a kernel cmdline;</li>
<li><p>Kernel –&gt; Hareware:<br>The Linux kernel will init hardwares for everything built ‘static’ in the kernel;</p>
</li>
<li><p>Kernel –&gt; Filesystem:<br>The root filesystem (via root=, rootfstype= etc parameters in the kernel cmdline) will be mounted;</p>
</li>
<li><p>Kernel –&gt; Init Process<br>At last kernel will start init process (PID 1);</p>
</li>
<li><p>OpenWRT –&gt; Preinit:<br>Before the real procd runs, a small init process is started. This process has the job of early system init.</p>
</li>
<li><p>OpenWRT –&gt; Procd:<br>Once preinit is complete the init process is done and will do an exec on the real procd. This will replace init as pid1 with an instance of procd running as the new pid 1. The watchdog file descriptor is not closed. Instead it is handed over to the new procd process. The debug_level will also be handed over to the new procd instance if it was set via command line or during preinit.</p>
</li>
</ul>
<p>OpenWRT system starts actually from step 4. In OpenWRT system this init process is not a normal process of Linux but a shell scripts desinaged for OpenWRT. Additionally this init process is also the first part of preinit of OpenWRT. Therefore this article will start analysis of this speciall init process.</p>
<h2 id="2-Preinit"><a href="#2-Preinit" class="headerlink" title="2. Preinit"></a>2. Preinit</h2><h3 id="2-1-etc-preinit"><a href="#2-1-etc-preinit" class="headerlink" title="2.1 /etc/preinit"></a>2.1 /etc/preinit</h3><p> OpenWRT has many patches for different kinds of hardwares and unique applications which do not exist in the mainline kernel. From such patches, which are generic patches for certain Linux kernel version and shared amount all the routers, are located in openwrt/target/linux/generic/patches-/. No matter which version of Linux you choose, you can always find a patch called 921-use_preinit_as_init.patch which injects the OpenWRT init process at the first place of init processes list. This patch is shown below:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- a/init/main.c</span><br><span class="line">+++ b/init/main.c</span><br><span class="line">@@ -960,7 +960,8 @@ static int __ref kernel_init(void *unuse</span><br><span class="line">panic(&quot;Requested init %s failed (error %d).&quot;,</span><br><span class="line">execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line">- if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">+ if (!try_to_run_init_process(&quot;/etc/preinit&quot;) ||</span><br><span class="line">+ !try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">!try_to_run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">!try_to_run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">!try_to_run_init_process(&quot;/bin/sh&quot;))</span><br></pre></td></tr></table></figure></p>
<p>It is obviously that the init process is located at /etc/ in the deivce filesystem or openwrt/package/base-files/files/etc/ of source tree. Next I will analyze this scripts in detail. As usual the source code of this preinit is firstly shown</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Copyright (C) 2006-2016 OpenWrt.org</span><br><span class="line"># Copyright (C) 2010 Vertical Communications</span><br><span class="line"> </span><br><span class="line">[ -z &quot;$PREINIT&quot; ] &amp;&amp; exec /sbin/init</span><br><span class="line"> </span><br><span class="line">export PATH=&quot;%PATH%&quot;</span><br><span class="line"> </span><br><span class="line">pi_ifname=</span><br><span class="line">pi_ip=192.168.1.1</span><br><span class="line">pi_broadcast=192.168.1.255</span><br><span class="line">pi_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_ifname=</span><br><span class="line">fs_failsafe_ip=192.168.1.1</span><br><span class="line">fs_failsafe_broadcast=192.168.1.255</span><br><span class="line">fs_failsafe_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_wait_timeout=2</span><br><span class="line"> </span><br><span class="line">pi_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_path=&quot;%PATH%&quot;</span><br><span class="line">pi_init_cmd=&quot;/sbin/init&quot;</span><br><span class="line"> </span><br><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br><span class="line"> </span><br><span class="line">boot_hook_init preinit_essential</span><br><span class="line">boot_hook_init preinit_main</span><br><span class="line">boot_hook_init failsafe</span><br><span class="line">boot_hook_init initramfs</span><br><span class="line">boot_hook_init preinit_mount_root</span><br><span class="line"> </span><br><span class="line">for pi_source_file in /lib/preinit/*; do</span><br><span class="line">. $pi_source_file</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">boot_run_hook preinit_essential</span><br><span class="line"> </span><br><span class="line">pi_mount_skip_next=false</span><br><span class="line">pi_jffs2_mount_success=false</span><br><span class="line">pi_failsafe_net_message=false</span><br><span class="line"> </span><br><span class="line">boot_run_hook preinit_main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>In this script, the first command is:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ -z &quot;$PREINIT&quot; ] &amp;&amp; exec /sbin/init</span><br></pre></td></tr></table></figure><br>According to the process from kernel to this script, the environment parameter PREINIT is NOT defined, thus /sbin/init will be excuted. The /sbin/init is actually the first init process of OpenWRT system. This program is one of programs from procd package. Another well-known program is procd that will be introduced later.</p>
<h3 id="2-3-sbin-init"><a href="#2-3-sbin-init" class="headerlink" title="2.3 /sbin/init"></a>2.3 /sbin/init</h3><p>We don’t need to analze the whole souce code of /sbin/init. At first the main function could give us a good overview. The main function of /sbin/init is located at procd/initd/init.c file. We don’t need to analze the whole souce code to understand. In the following, a diagram will be demonstrated to show the execution order.<br><img src="https://img-blog.csdnimg.cn/img_convert/099962b03d6f6459f8d5ffb9904914b1.png" alt="image"></p>
<ul>
<li><ol>
<li>early() is the first function in init. It has four main tasks:<ul>
<li><ol>
<li>early_mounts(): mount /proc, /sysfs, /dev, /tmp;</li>
</ol>
</li>
<li><ol>
<li>early_env(): set PATH parameter with /usr/sbin:/sbin:/usr/bin:/bin;</li>
</ol>
</li>
<li><ol>
<li>initializes /dev/console;</li>
</ol>
</li>
<li><ol>
<li>print the first message: “Console is a alive” from init as shown above;</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>cmdline() is the second function which reads the kernel boot command line from /proc/cmdline and parses init_debug parameter;</li>
</ol>
</li>
<li><ol>
<li>watchdog_init() initializes watchdog (/dev/watchdog) and print the second message “- watchdog -” as shown above;</li>
</ol>
</li>
<li><ol>
<li>fork() a new thread to let /sbin/kmodloader load device drivers regarding /etc/modules-boot.d/;</li>
</ol>
</li>
<li><ol>
<li>uloop_init() initializes the uloop which is an event loop implementation. Later procd and sh /etc/preinit will be managed by uloop;</li>
</ol>
</li>
<li><ol>
<li>preinit() has four main tasks:<ul>
<li><ol>
<li>prints the third message: “- preinit -” as shown above;</li>
</ol>
</li>
<li><ol>
<li>fork() a new thread to excute sh /etc/preinit. This will be the second time to excute this init script. A callback function called spawn_procd() will be excuted after sh /etc/preinit is finished.<br>Note: spawn_procd() will read system debug level from /tmp/debuglevel and set it to env DBGLVL. It also sets watchdog fd to env WDTFD. At last it will fork the real /sbin/procd as deamon.</li>
</ol>
</li>
<li><ol>
<li>set env variable PREINIT with setenv(“PREINIT”, “1”, 1);</li>
</ol>
</li>
<li><ol>
<li>fork() a new thread to excute /sbin/procd program with parameter -h /etc/hotplug-preinit.json.<br>Note: This new thread will be added into uloop by uloop_process_add() together with a callbakc function as</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugd_proc.cb = plugd_proc_cb;</span><br></pre></td></tr></table></figure>
<p>When /sbin/procd – h is finished, the callback function plugd_proc_cb()<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">plugd_proc_cb(struct uloop_process *proc, int ret)</span><br><span class="line">&#123;</span><br><span class="line">proc-&gt;pid = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>will be excuted. It is clear that it will set the pid with 0 to show that /sbin/procd – h is finished.</p>
<h3 id="2-2-etc-preinit-again"><a href="#2-2-etc-preinit-again" class="headerlink" title="2.2 /etc/preinit again"></a>2.2 /etc/preinit again</h3><p>Now the init process comes to /etc/preinit again. The first part of this script is shown below:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;%PATH%&quot;</span><br><span class="line"> </span><br><span class="line">pi_ifname=</span><br><span class="line">pi_ip=192.168.1.1</span><br><span class="line">pi_broadcast=192.168.1.255</span><br><span class="line">pi_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_ifname=</span><br><span class="line">fs_failsafe_ip=192.168.1.1</span><br><span class="line">fs_failsafe_broadcast=192.168.1.255</span><br><span class="line">fs_failsafe_netmask=255.255.255.0</span><br><span class="line"> </span><br><span class="line">fs_failsafe_wait_timeout=2</span><br><span class="line"> </span><br><span class="line">pi_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_path=&quot;%PATH%&quot;</span><br><span class="line">pi_init_cmd=&quot;/sbin/init&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>These statements are simply variables definition.</li>
<li>Then it defined functions from following locations<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>boot_hook_init is defined in /lib/functions/preinit.sh and used as<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boot_hook_init preinit_essential</span><br><span class="line">boot_hook_init preinit_main</span><br><span class="line">boot_hook_init failsafe</span><br><span class="line">boot_hook_init initramfs</span><br><span class="line">boot_hook_init preinit_mount_root</span><br></pre></td></tr></table></figure><br>to defined 5 hook nodes. In the following loop<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for pi_source_file in /lib/preinit/*; do</span><br><span class="line">. $pi_source_file</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>scripts located in /lib/preinit/ will be excuted. These scripts have defined functions which will be added to coresponding hook nodes by boot_hook_add.</p>
<h2 id="At-last-etc-preinit-will-excute-boot-run-hook-to-find-and-excute-functions-hooked-at-certain-node-In-current-system-it-will-start-from-boot-run-hook-preinit-main"><a href="#At-last-etc-preinit-will-excute-boot-run-hook-to-find-and-excute-functions-hooked-at-certain-node-In-current-system-it-will-start-from-boot-run-hook-preinit-main" class="headerlink" title="At last /etc/preinit will excute boot_run_hook to find and excute functions hooked at certain node. In current system it will start from boot_run_hook preinit_main."></a>At last /etc/preinit will excute boot_run_hook to find and excute functions hooked at certain node. In current system it will start from boot_run_hook preinit_main.</h2><h3 id="3-Watchdog"><a href="#3-Watchdog" class="headerlink" title="3. Watchdog"></a>3. Watchdog</h3><h2 id="If-the-watchdog-dev-dev-watchdog-exists-setting-watchdog-timeout-as-30-second-If-the-Linux-kernel-doese-not-receive-any-data-the-system-will-be-rebooted-The-process-use-uloop-to-write-some-data-into-Linux-kernel-periodly-5s-which-indicates-that-the-process-is-woring-well"><a href="#If-the-watchdog-dev-dev-watchdog-exists-setting-watchdog-timeout-as-30-second-If-the-Linux-kernel-doese-not-receive-any-data-the-system-will-be-rebooted-The-process-use-uloop-to-write-some-data-into-Linux-kernel-periodly-5s-which-indicates-that-the-process-is-woring-well" class="headerlink" title="If the watchdog dev /dev/watchdog exists, setting watchdog timeout as 30 second. If the Linux kernel doese not receive any data, the system will be rebooted. The process use uloop to write some data into Linux kernel periodly (5s), which indicates that the process is woring well."></a>If the watchdog dev /dev/watchdog exists, setting watchdog timeout as 30 second. If the Linux kernel doese not receive any data, the system will be rebooted. The process use uloop to write some data into Linux kernel periodly (5s), which indicates that the process is woring well.</h2><h3 id="4-procd"><a href="#4-procd" class="headerlink" title="4. procd"></a>4. procd</h3><p>LEDE uses procd for booting the system, managing processes and handling parts of the kernel/userland interaction. It can be considered similar to systemd on full blown distributions. Here is a list of tasks that procd will do for us</p>
<p>Procd will first do some basic process init such as setting itself to be owner of its own process group and setting up signals. We are now ready to bring up the userland in the following order</p>
</blockquote>
<ul>
<li>find out if a watchdog file descriptor was passed by the init process and start up the watchdog;</li>
<li>setup /dev/console to be our stdin/out/err;</li>
<li>start the coldplug process using the full rule set (/etc/hotplug.json). This is done by manually triggering all events that have already happened using udevtrigger;</li>
<li>start ubus, register it as a service and connect to it.<br>The basic system bringup is now complete, procd is up and running and can start handling daemons and services.<blockquote>
<p>procd has 6 states, STATE_EARLY, STATE_UBUS, STATE_INIT,STATE_RUNNING,STATE_SHUTDOWN, STATE_HALT. the procd state is changed from the first one until the last one. Current state is located in global variable state. The state can be changed by calling procd_state_next()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void state_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">char ubus_cmd[] = &quot;/sbin/ubusd&quot;;</span><br><span class="line"> </span><br><span class="line">switch (state) &#123;</span><br><span class="line">case STATE_EARLY:</span><br><span class="line">LOG(&quot;- early -\n&quot;);</span><br><span class="line">watchdog_init(0);</span><br><span class="line">hotplug(&quot;/etc/hotplug.json&quot;);</span><br><span class="line">procd_coldplug();</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">case STATE_UBUS:</span><br><span class="line">// try to reopen incase the wdt was not available before coldplug</span><br><span class="line">watchdog_init(0);</span><br><span class="line">set_stdio(&quot;console&quot;);</span><br><span class="line">LOG(&quot;- ubus -\n&quot;);</span><br><span class="line">procd_connect_ubus();</span><br><span class="line">service_start_early(&quot;ubus&quot;, ubus_cmd);</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">case STATE_INIT:</span><br><span class="line">LOG(&quot;- init -\n&quot;);</span><br><span class="line">procd_inittab();</span><br><span class="line">procd_inittab_run(&quot;respawn&quot;);</span><br><span class="line">procd_inittab_run(&quot;askconsole&quot;);</span><br><span class="line">procd_inittab_run(&quot;askfirst&quot;);</span><br><span class="line">procd_inittab_run(&quot;sysinit&quot;);</span><br><span class="line"> </span><br><span class="line">// switch to syslog log channel</span><br><span class="line">ulog_open(ULOG_SYSLOG, LOG_DAEMON, &quot;procd&quot;);</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">case STATE_RUNNING:</span><br><span class="line">LOG(&quot;- init complete -\n&quot;);</span><br><span class="line">procd_inittab_run(&quot;respawnlate&quot;);</span><br><span class="line">procd_inittab_run(&quot;askconsolelate&quot;);</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">case STATE_SHUTDOWN:</span><br><span class="line">/* Redirect output to the console for the users&#x27; benefit */</span><br><span class="line">set_console();</span><br><span class="line">LOG(&quot;- shutdown -\n&quot;);</span><br><span class="line">procd_inittab_run(&quot;shutdown&quot;);</span><br><span class="line">sync();</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">case STATE_HALT:</span><br><span class="line">// To prevent killed processes from interrupting the sleep</span><br><span class="line">signal(SIGCHLD, SIG_IGN);</span><br><span class="line">LOG(&quot;- SIGTERM processes -\n&quot;);</span><br><span class="line">kill(-1, SIGTERM);</span><br><span class="line">sync();</span><br><span class="line">sleep(1);</span><br><span class="line">LOG(&quot;- SIGKILL processes -\n&quot;);</span><br><span class="line">kill(-1, SIGKILL);</span><br><span class="line">sync();</span><br><span class="line">sleep(1);</span><br><span class="line">#ifndef DISABLE_INIT</span><br><span class="line">if (reboot_event == RB_POWER_OFF)</span><br><span class="line">LOG(&quot;- power down -\n&quot;);</span><br><span class="line">else</span><br><span class="line">LOG(&quot;- reboot -\n&quot;);</span><br><span class="line"> </span><br><span class="line">/* Allow time for last message to reach serial console, etc */</span><br><span class="line">sleep(1);</span><br><span class="line"> </span><br><span class="line">/* We have to fork here, since the kernel calls do_exit(EXIT_SUCCESS)</span><br><span class="line">* in linux/kernel/sys.c, which can cause the machine to panic when</span><br><span class="line">* the init process exits... */</span><br><span class="line">if (!vfork( )) &#123; /* child */</span><br><span class="line">reboot(reboot_event);</span><br><span class="line">_exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">while (1)</span><br><span class="line">sleep(1);</span><br><span class="line">#else</span><br><span class="line">exit(0);</span><br><span class="line">#endif</span><br><span class="line">break;</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line">ERROR(&quot;Unhandled state %d\n&quot;, state);</span><br><span class="line">return;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-STATE-EARLY"><a href="#4-1-STATE-EARLY" class="headerlink" title="4.1 STATE_EARLY"></a>4.1 STATE_EARLY</h3><p>In this state some preparartion work will be done before init.</p>
</blockquote>
</li>
<li>init watchdog. Timeout is 30s;</li>
<li>hotplug(“/etc/hotplug.json”); will enable monitoring hotplug event according to the rules defined in /etc/hotplug.json;</li>
<li>in procd_coldplug function, /dev is mouted. udevtrigger will generate coldplug events for hotplug monitoring;</li>
<li>When udevstrigger is finished, its callback function procd_state_next() will change the state from STATE_EARLY to STATE_UBUS;</li>
</ul>
<h3 id="4-2-STATE-UBUS"><a href="#4-2-STATE-UBUS" class="headerlink" title="4.2 STATE_UBUS"></a>4.2 STATE_UBUS</h3><ul>
<li>watchdog_init(0); Init watchdoa again;</li>
<li>set_stdio(“console”); Setup standar IO device to console;</li>
<li>procd_connect_ubus(void); A timer is set to reconnect periodly with ubusd even ubusd may not exist yet. uloop_run() will run after init work finished. After procd connects ubusd, it will register service main_object, system_object and watch_object;<ul>
<li>in ubus_connect_cb, /var/run/ubus.sock（UBUS_UNIX_SOCKET) will be used to commnunicate with ubus. The state will be changed to STATE_INIT after the connection is successully builded.</li>
</ul>
</li>
<li>service_init(); Init AVL tree for services and validators;</li>
<li>service_start_early(“ubus”, ubus_cmd); Start ubusd service deamon;</li>
</ul>
<h3 id="4-3-STATE-INIT"><a href="#4-3-STATE-INIT" class="headerlink" title="4.3 STATE_INIT"></a>4.3 STATE_INIT</h3><p>in this state the real init work will be done</p>
<ul>
<li>Add global link table actions from /etc/inittab;</li>
<li>Sequential loading respawn, askconsole, askfirst and sysinit commands;</li>
<li>procd_inittab_run() Callback functions of <em>respawn*</em>, askconsole, askfirst and sysinit will be excuted. Regarding /etc/inittab, callback functions of sysinit and askfirst will be runned.<ul>
<li><strong>askfirst</strong> –&gt; askfirst(): Start /sbin/askfirst to show Please press Enter to activate this console and then /bin/ash –login will be excuted.</li>
<li><strong>sysinit</strong> –&gt; runrc(): It wll call all the startup scripts which are located on /etc/rc.d. Actually it calls add_initd() to fork a process for every scripts, repectively, whichi is handled by struct runqueue. After that the callback function will call rcdone() to change the state from STATE_INIT to STATE_RUNNING.</li>
</ul>
</li>
</ul>
<h3 id="4-4-STATE-RUNNING"><a href="#4-4-STATE-RUNNING" class="headerlink" title="4.4 STATE_RUNNING"></a>4.4 STATE_RUNNING</h3><p>In this state the procd will in the uloop_run() loop.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h2><p><a target="_blank" rel="noopener" href="https://wiki.openwrt.org/doc/techref/preinit_mount">https://wiki.openwrt.org/doc/techref/preinit_mount</a><br><a target="_blank" rel="noopener" href="https://wiki.openwrt.org/doc/techref/requirements.boot.process">https://wiki.openwrt.org/doc/techref/requirements.boot.process</a><br><a target="_blank" rel="noopener" href="http://trac.gateworks.com/wiki/OpenWrt/init">http://trac.gateworks.com/wiki/OpenWrt/init</a><br><a target="_blank" rel="noopener" href="https://www.lede-project.org/docs/procd.html">https://www.lede-project.org/docs/procd.html</a><br><a target="_blank" rel="noopener" href="http://ask.wrtnode.cc/question/43">http://ask.wrtnode.cc/question/43</a><br><a target="_blank" rel="noopener" href="https://wiki.microduino.cc/index.php/%E7%AC%AC%E4%B8%80%E8%AF%BE–MicroWRT_%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B#.E5.86.85.E6.A0.B8.E8.A1.A5.E4.B8.81">https://wiki.microduino.cc/index.php/%E7%AC%AC%E4%B8%80%E8%AF%BE–MicroWRT_%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B#.E5.86.85.E6.A0.B8.E8.A1.A5.E4.B8.81</a><br><a target="_blank" rel="noopener" href="http://lirobo.blogspot.de/2014/07/openwrt-boot.html">http://lirobo.blogspot.de/2014/07/openwrt-boot.html</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/rohens-hbg/p/5049085.html">http://www.cnblogs.com/rohens-hbg/p/5049085.html</a><br><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/shaokunyang@163.com/openwrt-cc-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">http://blog.leanote.com/post/shaokunyang@163.com/openwrt-cc-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B</a><br><a target="_blank" rel="noopener" href="http://www.mamicode.com/info-detail-107649.html">http://www.mamicode.com/info-detail-107649.html</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/wwx0715/article/details/41725917">http://blog.csdn.net/wwx0715/article/details/41725917</a><br><a target="_blank" rel="noopener" href="http://lirobo.blogspot.de/search/label/OpenWrt">http://lirobo.blogspot.de/search/label/OpenWrt</a><br><a target="_blank" rel="noopener" href="https://wiki.microduino.cn/index.php/MicroWRT_(OpenWRT%E5%85%BC%E5%AE%B9%E6%9D%BF%EF%BC%89%E6%95%99%E7%A8%8B">https://wiki.microduino.cn/index.php/MicroWRT_(OpenWRT%E5%85%BC%E5%AE%B9%E6%9D%BF%EF%BC%89%E6%95%99%E7%A8%8B</a><br><a target="_blank" rel="noopener" href="http://see.sl088.com/wiki/Openwrt_%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">http://see.sl088.com/wiki/Openwrt_%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002392043">https://segmentfault.com/a/1190000002392043</a><br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-26598889-id-3060545.html">http://blog.chinaunix.net/uid-26598889-id-3060545.html</a><br><a target="_blank" rel="noopener" href="http://www.51hei.com/bbs/dpj-46073-1.html">http://www.51hei.com/bbs/dpj-46073-1.html</a><br><a target="_blank" rel="noopener" href="http://www.programdevelop.com/4531245/">http://www.programdevelop.com/4531245/</a></p>
<h1 id="十三、ubus"><a href="#十三、ubus" class="headerlink" title="十三、ubus"></a>十三、ubus</h1><blockquote>
<p>ubus是openwrt下的进程间通讯协议，可以用来获取OpenWrt核心组件的信息，比如iwinfo、uci、service。ubus底层采用的是unix socket，通讯采用的数据结构是json。shell、c、lua都可以使用ubus来实现进程间通讯。ubus采用的是托管方式，后端的消息传递是由ubusd程序来实现的。OpenWrt中很多项目是基于ubus的，比如netifd、ubus-scriptd。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-developer/ubus">https://openwrt.org/docs/guide-developer/ubus</a></p>
<blockquote>
<p>netifd/uci 交给ubus托管</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/techref/ubus">https://openwrt.org/docs/techref/ubus</a><br><img src="https://img-blog.csdnimg.cn/20210713221414601.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713221614298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210713221714180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<h1 id="十四、hotplug机制"><a href="#十四、hotplug机制" class="headerlink" title="十四、hotplug机制"></a>十四、hotplug机制</h1><p><strong>ubus是用户态</strong></p>
<blockquote>
<p>hotplug机制是linux内核提供的一种消息通知机制，主要用来实现内核态事件向用户态传递。OpenWrt下的ubus也类似，一个是用户态的，而hotplug是内核态的，其功能都是用来消息传递。linux早期的hotplug机制并没有现在这么复杂，在2.4内核的时候只是针对usb、pci子系统，只是简单的hotplug调用进程，后面才使用netlink机制来实现通知机制。当时我主要用hotplug机制来实现usb 3g网卡的模式转换（配合usbmodswitch），现在hotplug有更广泛的使用场景。</p>
<p>OpenWrt中hotplug机制基本上和传统Linux下的实现类似，只是hotplug事件监听是procd（注：早期OpenWrt采用的是hotplug2），其他系统可能是由hotplug2或其他。OpenWrt常见的按键检测、驱动加载都是基于hotplug机制来实现的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://linux-hotplug.sourceforge.net/kernel/kernel.html">http://linux-hotplug.sourceforge.net/kernel/kernel.html</a></p>
<h1 id="十五、opkg-包管理机制"><a href="#十五、opkg-包管理机制" class="headerlink" title="十五、opkg 包管理机制"></a>十五、opkg 包管理机制</h1><p>opkg是OpenWrt的包管理系统，opkg源自于optware项目。包管理主要包含几大部分：安装脚本、卸载脚本、程序和库、配置文件、程序依赖关系、版本信息。</p>
<blockquote>
<ol>
<li>Redhat: rpm</li>
<li>Debain: deb</li>
<li>Openwrt: ipk</li>
</ol>
</blockquote>
<h1 id="十六、创建OpenWrt-Package"><a href="#十六、创建OpenWrt-Package" class="headerlink" title="十六、创建OpenWrt Package"></a>十六、创建OpenWrt Package</h1><p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-developer/packages">https://openwrt.org/docs/guide-developer/packages</a></p>
<p>最好现在本机测试没问题之后，才烧到路由器上去调试</p>
<p>在系统里面,为新项目新建一个项目文件夹，将需要的代码copy到这个文件夹。不要动openwrt build成功的golden源码。</p>
<p>将src的代码调试到没问题之后，才编译到package</p>
<p>w@w:/home/openwrt/package/example/src$ ls<br>Makefile  myapp.c<br>w@w:/home/openwrt/package/example/src$ make<br>cc  -o myapp myapp.c -Wall<br>w@w:/home/openwrt/package/example/src$ ls<br>Makefile  myapp  myapp.c<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## myapp.c, 位于/home/openwrt/package/example/src 目录下面</span><br><span class="line">/*</span><br><span class="line"> * otrx</span><br><span class="line"> *</span><br><span class="line"> * Copyright (C) 2015-2017 Rafał Miłecki &lt;zajec5@gmail.com&gt;</span><br><span class="line"> *</span><br><span class="line"> * This program is free software; you can redistribute it and/or modify it</span><br><span class="line"> * under the terms of the GNU General Public License as published by the Free</span><br><span class="line"> * Software Foundation; either version 2 of the License, or (at your option)</span><br><span class="line"> * any later version.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;byteswap.h&gt;</span><br><span class="line">#include &lt;endian.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">#if !defined(__BYTE_ORDER)</span><br><span class="line">#error &quot;Unknown byte order&quot;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#if __BYTE_ORDER == __BIG_ENDIAN</span><br><span class="line">#define cpu_to_le32(x)  bswap_32(x)</span><br><span class="line">#define le32_to_cpu(x)  bswap_32(x)</span><br><span class="line">#elif __BYTE_ORDER == __LITTLE_ENDIAN</span><br><span class="line">#define cpu_to_le32(x)  (x)</span><br><span class="line">#define le32_to_cpu(x)  (x)</span><br><span class="line">#else</span><br><span class="line">#error &quot;Unsupported endianness&quot;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#define TRX_MAGIC           0x30524448</span><br><span class="line">#define TRX_FLAGS_OFFSET        12</span><br><span class="line">#define TRX_MAX_PARTS           3</span><br><span class="line"> </span><br><span class="line">struct trx_header &#123;</span><br><span class="line">    uint32_t magic;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    uint32_t crc32;</span><br><span class="line">    uint16_t flags;</span><br><span class="line">    uint16_t version;</span><br><span class="line">    uint32_t offset[3];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">char *trx_path;</span><br><span class="line">size_t trx_offset = 0;</span><br><span class="line">char *partition[TRX_MAX_PARTS] = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">static inline size_t otrx_min(size_t x, size_t y) &#123;</span><br><span class="line">    return x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**************************************************</span><br><span class="line"> * CRC32</span><br><span class="line"> **************************************************/</span><br><span class="line"> </span><br><span class="line">static const uint32_t crc32_tbl[] = &#123;</span><br><span class="line">    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,</span><br><span class="line">    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,</span><br><span class="line">    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,</span><br><span class="line">    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,</span><br><span class="line">    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,</span><br><span class="line">    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,</span><br><span class="line">    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,</span><br><span class="line">    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,</span><br><span class="line">    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,</span><br><span class="line">    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,</span><br><span class="line">    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,</span><br><span class="line">    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,</span><br><span class="line">    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,</span><br><span class="line">    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,</span><br><span class="line">    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,</span><br><span class="line">    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,</span><br><span class="line">    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,</span><br><span class="line">    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,</span><br><span class="line">    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,</span><br><span class="line">    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,</span><br><span class="line">    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,</span><br><span class="line">    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,</span><br><span class="line">    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,</span><br><span class="line">    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,</span><br><span class="line">    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,</span><br><span class="line">    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,</span><br><span class="line">    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,</span><br><span class="line">    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,</span><br><span class="line">    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,</span><br><span class="line">    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,</span><br><span class="line">    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,</span><br><span class="line">    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,</span><br><span class="line">    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,</span><br><span class="line">    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,</span><br><span class="line">    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,</span><br><span class="line">    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,</span><br><span class="line">    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,</span><br><span class="line">    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,</span><br><span class="line">    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,</span><br><span class="line">    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,</span><br><span class="line">    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,</span><br><span class="line">    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,</span><br><span class="line">    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,</span><br><span class="line">    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,</span><br><span class="line">    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,</span><br><span class="line">    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,</span><br><span class="line">    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,</span><br><span class="line">    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,</span><br><span class="line">    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,</span><br><span class="line">    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,</span><br><span class="line">    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,</span><br><span class="line">    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,</span><br><span class="line">    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,</span><br><span class="line">    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,</span><br><span class="line">    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,</span><br><span class="line">    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,</span><br><span class="line">    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,</span><br><span class="line">    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,</span><br><span class="line">    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,</span><br><span class="line">    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,</span><br><span class="line">    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,</span><br><span class="line">    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,</span><br><span class="line">    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,</span><br><span class="line">    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">uint32_t otrx_crc32(uint32_t crc, uint8_t *buf, size_t len) &#123;</span><br><span class="line">    while (len) &#123;</span><br><span class="line">        crc = crc32_tbl[(crc ^ *buf) &amp; 0xff] ^ (crc &gt;&gt; 8);</span><br><span class="line">        buf++;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**************************************************</span><br><span class="line"> * Check</span><br><span class="line"> **************************************************/</span><br><span class="line"> </span><br><span class="line">static void otrx_check_parse_options(int argc, char **argv) &#123;</span><br><span class="line">    int c;</span><br><span class="line"> </span><br><span class="line">    while ((c = getopt(argc, argv, &quot;o:&quot;)) != -1) &#123;</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &#x27;o&#x27;:</span><br><span class="line">            trx_offset = atoi(optarg);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int otrx_check(int argc, char **argv) &#123;</span><br><span class="line">    FILE *trx;</span><br><span class="line">    struct trx_header hdr;</span><br><span class="line">    size_t bytes, length;</span><br><span class="line">    uint8_t buf[1024];</span><br><span class="line">    uint32_t crc32;</span><br><span class="line">    int err = 0;</span><br><span class="line"> </span><br><span class="line">    if (argc &lt; 3) &#123;</span><br><span class="line">        fprintf(stderr, &quot;No TRX file passed\n&quot;);</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    trx_path = argv[2];</span><br><span class="line"> </span><br><span class="line">    optind = 3;</span><br><span class="line">    otrx_check_parse_options(argc, argv);</span><br><span class="line"> </span><br><span class="line">    trx = fopen(trx_path, &quot;r&quot;);</span><br><span class="line">    if (!trx) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t open %s\n&quot;, trx_path);</span><br><span class="line">        err = -EACCES;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fseek(trx, trx_offset, SEEK_SET);</span><br><span class="line">    bytes = fread(&amp;hdr, 1, sizeof(hdr), trx);</span><br><span class="line">    if (bytes != sizeof(hdr)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t read %s header\n&quot;, trx_path);</span><br><span class="line">        err =  -EIO;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (le32_to_cpu(hdr.magic) != TRX_MAGIC) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Invalid TRX magic: 0x%08x\n&quot;, le32_to_cpu(hdr.magic));</span><br><span class="line">        err =  -EINVAL;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    length = le32_to_cpu(hdr.length);</span><br><span class="line">    if (length &lt; sizeof(hdr)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Length read from TRX too low (%zu B)\n&quot;, length);</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    crc32 = 0xffffffff;</span><br><span class="line">    fseek(trx, trx_offset + TRX_FLAGS_OFFSET, SEEK_SET);</span><br><span class="line">    length -= TRX_FLAGS_OFFSET;</span><br><span class="line">    while ((bytes = fread(buf, 1, otrx_min(sizeof(buf), length), trx)) &gt; 0) &#123;</span><br><span class="line">        crc32 = otrx_crc32(crc32, buf, bytes);</span><br><span class="line">        length -= bytes;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (length) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t read last %zd B of data from %s\n&quot;, length, trx_path);</span><br><span class="line">        err = -EIO;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (crc32 != le32_to_cpu(hdr.crc32)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Invalid data crc32: 0x%08x instead of 0x%08x\n&quot;, crc32, le32_to_cpu(hdr.crc32));</span><br><span class="line">        err =  -EINVAL;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Found a valid TRX version %d\n&quot;, le32_to_cpu(hdr.version));</span><br><span class="line"> </span><br><span class="line">err_close:</span><br><span class="line">    fclose(trx);</span><br><span class="line">out:</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**************************************************</span><br><span class="line"> * Create</span><br><span class="line"> **************************************************/</span><br><span class="line"> </span><br><span class="line">static ssize_t otrx_create_append_file(FILE *trx, const char *in_path) &#123;</span><br><span class="line">    FILE *in;</span><br><span class="line">    size_t bytes;</span><br><span class="line">    ssize_t length = 0;</span><br><span class="line">    uint8_t buf[1024];</span><br><span class="line"> </span><br><span class="line">    in = fopen(in_path, &quot;r&quot;);</span><br><span class="line">    if (!in) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t open %s\n&quot;, in_path);</span><br><span class="line">        return -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while ((bytes = fread(buf, 1, sizeof(buf), in)) &gt; 0) &#123;</span><br><span class="line">        if (fwrite(buf, 1, bytes, trx) != bytes) &#123;</span><br><span class="line">            fprintf(stderr, &quot;Couldn&#x27;t write %zu B to %s\n&quot;, bytes, trx_path);</span><br><span class="line">            length = -EIO;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        length += bytes;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fclose(in);</span><br><span class="line"> </span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static ssize_t otrx_create_append_zeros(FILE *trx, size_t length) &#123;</span><br><span class="line">    uint8_t *buf;</span><br><span class="line"> </span><br><span class="line">    buf = malloc(length);</span><br><span class="line">    if (!buf)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    memset(buf, 0, length);</span><br><span class="line"> </span><br><span class="line">    if (fwrite(buf, 1, length, trx) != length) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t write %zu B to %s\n&quot;, length, trx_path);</span><br><span class="line">        free(buf);</span><br><span class="line">        return -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    free(buf);</span><br><span class="line"> </span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static ssize_t otrx_create_align(FILE *trx, size_t curr_offset, size_t alignment) &#123;</span><br><span class="line">    if (curr_offset &amp; (alignment - 1)) &#123;</span><br><span class="line">        size_t length = alignment - (curr_offset % alignment);</span><br><span class="line">        return otrx_create_append_zeros(trx, length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int otrx_create_write_hdr(FILE *trx, struct trx_header *hdr) &#123;</span><br><span class="line">    size_t bytes, length;</span><br><span class="line">    uint8_t buf[1024];</span><br><span class="line">    uint32_t crc32;</span><br><span class="line"> </span><br><span class="line">    hdr-&gt;magic = cpu_to_le32(TRX_MAGIC);</span><br><span class="line">    hdr-&gt;version = 1;</span><br><span class="line"> </span><br><span class="line">    fseek(trx, 0, SEEK_SET);</span><br><span class="line">    bytes = fwrite(hdr, 1, sizeof(struct trx_header), trx);</span><br><span class="line">    if (bytes != sizeof(struct trx_header)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t write TRX header to %s\n&quot;, trx_path);</span><br><span class="line">        return -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    length = le32_to_cpu(hdr-&gt;length);</span><br><span class="line"> </span><br><span class="line">    crc32 = 0xffffffff;</span><br><span class="line">    fseek(trx, TRX_FLAGS_OFFSET, SEEK_SET);</span><br><span class="line">    length -= TRX_FLAGS_OFFSET;</span><br><span class="line">    while ((bytes = fread(buf, 1, otrx_min(sizeof(buf), length), trx)) &gt; 0) &#123;</span><br><span class="line">        crc32 = otrx_crc32(crc32, buf, bytes);</span><br><span class="line">        length -= bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    hdr-&gt;crc32 = cpu_to_le32(crc32);</span><br><span class="line"> </span><br><span class="line">    fseek(trx, 0, SEEK_SET);</span><br><span class="line">    bytes = fwrite(hdr, 1, sizeof(struct trx_header), trx);</span><br><span class="line">    if (bytes != sizeof(struct trx_header)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t write TRX header to %s\n&quot;, trx_path);</span><br><span class="line">        return -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int otrx_create(int argc, char **argv) &#123;</span><br><span class="line">    FILE *trx;</span><br><span class="line">    struct trx_header hdr = &#123;&#125;;</span><br><span class="line">    ssize_t sbytes;</span><br><span class="line">    size_t curr_idx = 0;</span><br><span class="line">    size_t curr_offset = sizeof(hdr);</span><br><span class="line">    int c;</span><br><span class="line">    int err = 0;</span><br><span class="line"> </span><br><span class="line">    if (argc &lt; 3) &#123;</span><br><span class="line">        fprintf(stderr, &quot;No TRX file passed\n&quot;);</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    trx_path = argv[2];</span><br><span class="line"> </span><br><span class="line">    trx = fopen(trx_path, &quot;w+&quot;);</span><br><span class="line">    if (!trx) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t open %s\n&quot;, trx_path);</span><br><span class="line">        err = -EACCES;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(trx, curr_offset, SEEK_SET);</span><br><span class="line"> </span><br><span class="line">    optind = 3;</span><br><span class="line">    while ((c = getopt(argc, argv, &quot;f:A:a:b:&quot;)) != -1) &#123;</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &#x27;f&#x27;:</span><br><span class="line">            if (curr_idx &gt;= TRX_MAX_PARTS) &#123;</span><br><span class="line">                err = -ENOSPC;</span><br><span class="line">                fprintf(stderr, &quot;Reached TRX partitions limit, no place for %s\n&quot;, optarg);</span><br><span class="line">                goto err_close;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            sbytes = otrx_create_append_file(trx, optarg);</span><br><span class="line">            if (sbytes &lt; 0) &#123;</span><br><span class="line">                fprintf(stderr, &quot;Failed to append file %s\n&quot;, optarg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                hdr.offset[curr_idx++] = curr_offset;</span><br><span class="line">                curr_offset += sbytes;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            sbytes = otrx_create_align(trx, curr_offset, 4);</span><br><span class="line">            if (sbytes &lt; 0)</span><br><span class="line">                fprintf(stderr, &quot;Failed to append zeros\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                curr_offset += sbytes;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            sbytes = otrx_create_append_file(trx, optarg);</span><br><span class="line">            if (sbytes &lt; 0) &#123;</span><br><span class="line">                fprintf(stderr, &quot;Failed to append file %s\n&quot;, optarg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                curr_offset += sbytes;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            sbytes = otrx_create_align(trx, curr_offset, 4);</span><br><span class="line">            if (sbytes &lt; 0)</span><br><span class="line">                fprintf(stderr, &quot;Failed to append zeros\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                curr_offset += sbytes;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;a&#x27;:</span><br><span class="line">            sbytes = otrx_create_align(trx, curr_offset, strtol(optarg, NULL, 0));</span><br><span class="line">            if (sbytes &lt; 0)</span><br><span class="line">                fprintf(stderr, &quot;Failed to append zeros\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                curr_offset += sbytes;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;b&#x27;:</span><br><span class="line">            sbytes = strtol(optarg, NULL, 0) - curr_offset;</span><br><span class="line">            if (sbytes &lt; 0) &#123;</span><br><span class="line">                fprintf(stderr, &quot;Current TRX length is 0x%zx, can&#x27;t pad it with zeros to 0x%lx\n&quot;, curr_offset, strtol(optarg, NULL, 0));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sbytes = otrx_create_append_zeros(trx, sbytes);</span><br><span class="line">                if (sbytes &lt; 0)</span><br><span class="line">                    fprintf(stderr, &quot;Failed to append zeros\n&quot;);</span><br><span class="line">                else</span><br><span class="line">                    curr_offset += sbytes;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (err)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sbytes = otrx_create_align(trx, curr_offset, 0x1000);</span><br><span class="line">    if (sbytes &lt; 0)</span><br><span class="line">        fprintf(stderr, &quot;Failed to append zeros\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        curr_offset += sbytes;</span><br><span class="line"> </span><br><span class="line">    hdr.length = curr_offset;</span><br><span class="line">    otrx_create_write_hdr(trx, &amp;hdr);</span><br><span class="line">err_close:</span><br><span class="line">    fclose(trx);</span><br><span class="line">out:</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**************************************************</span><br><span class="line"> * Extract</span><br><span class="line"> **************************************************/</span><br><span class="line"> </span><br><span class="line">static void otrx_extract_parse_options(int argc, char **argv) &#123;</span><br><span class="line">    int c;</span><br><span class="line"> </span><br><span class="line">    while ((c = getopt(argc, argv, &quot;c:e:o:1:2:3:&quot;)) != -1) &#123;</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &#x27;o&#x27;:</span><br><span class="line">            trx_offset = atoi(optarg);</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;1&#x27;:</span><br><span class="line">            partition[0] = optarg;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;2&#x27;:</span><br><span class="line">            partition[1] = optarg;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;3&#x27;:</span><br><span class="line">            partition[2] = optarg;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int otrx_extract_copy(FILE *trx, size_t offset, size_t length, char *out_path) &#123;</span><br><span class="line">    FILE *out;</span><br><span class="line">    size_t bytes;</span><br><span class="line">    uint8_t *buf;</span><br><span class="line">    int err = 0;</span><br><span class="line"> </span><br><span class="line">    out = fopen(out_path, &quot;w&quot;);</span><br><span class="line">    if (!out) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t open %s\n&quot;, out_path);</span><br><span class="line">        err = -EACCES;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    buf = malloc(length);</span><br><span class="line">    if (!buf) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t alloc %zu B buffer\n&quot;, length);</span><br><span class="line">        err =  -ENOMEM;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fseek(trx, offset, SEEK_SET);</span><br><span class="line">    bytes = fread(buf, 1, length, trx);</span><br><span class="line">    if (bytes != length) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t read %zu B of data from %s\n&quot;, length, trx_path);</span><br><span class="line">        err =  -ENOMEM;</span><br><span class="line">        goto err_free_buf;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    bytes = fwrite(buf, 1, length, out);</span><br><span class="line">    if (bytes != length) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t write %zu B to %s\n&quot;, length, out_path);</span><br><span class="line">        err =  -ENOMEM;</span><br><span class="line">        goto err_free_buf;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Extracted 0x%zx bytes into %s\n&quot;, length, out_path);</span><br><span class="line"> </span><br><span class="line">err_free_buf:</span><br><span class="line">    free(buf);</span><br><span class="line">err_close:</span><br><span class="line">    fclose(out);</span><br><span class="line">out:</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int otrx_extract(int argc, char **argv) &#123;</span><br><span class="line">    FILE *trx;</span><br><span class="line">    struct trx_header hdr;</span><br><span class="line">    size_t bytes;</span><br><span class="line">    int i;</span><br><span class="line">    int err = 0;</span><br><span class="line"> </span><br><span class="line">    if (argc &lt; 3) &#123;</span><br><span class="line">        fprintf(stderr, &quot;No TRX file passed\n&quot;);</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    trx_path = argv[2];</span><br><span class="line"> </span><br><span class="line">    optind = 3;</span><br><span class="line">    otrx_extract_parse_options(argc, argv);</span><br><span class="line"> </span><br><span class="line">    trx = fopen(trx_path, &quot;r&quot;);</span><br><span class="line">    if (!trx) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t open %s\n&quot;, trx_path);</span><br><span class="line">        err = -EACCES;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fseek(trx, trx_offset, SEEK_SET);</span><br><span class="line">    bytes = fread(&amp;hdr, 1, sizeof(hdr), trx);</span><br><span class="line">    if (bytes != sizeof(hdr)) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Couldn&#x27;t read %s header\n&quot;, trx_path);</span><br><span class="line">        err =  -EIO;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (le32_to_cpu(hdr.magic) != TRX_MAGIC) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Invalid TRX magic: 0x%08x\n&quot;, le32_to_cpu(hdr.magic));</span><br><span class="line">        err =  -EINVAL;</span><br><span class="line">        goto err_close;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (i = 0; i &lt; TRX_MAX_PARTS; i++) &#123;</span><br><span class="line">        size_t length;</span><br><span class="line"> </span><br><span class="line">        if (!partition[i])</span><br><span class="line">            continue;</span><br><span class="line">        if (!hdr.offset[i]) &#123;</span><br><span class="line">            printf(&quot;TRX doesn&#x27;t contain partition %d, can&#x27;t extract %s\n&quot;, i + 1, partition[i]);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (i + 1 &gt;= TRX_MAX_PARTS || !hdr.offset[i + 1])</span><br><span class="line">            length = le32_to_cpu(hdr.length) - le32_to_cpu(hdr.offset[i]);</span><br><span class="line">        else</span><br><span class="line">            length = le32_to_cpu(hdr.offset[i + 1]) - le32_to_cpu(hdr.offset[i]);</span><br><span class="line"> </span><br><span class="line">        otrx_extract_copy(trx, trx_offset + le32_to_cpu(hdr.offset[i]), length, partition[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">err_close:</span><br><span class="line">    fclose(trx);</span><br><span class="line">out:</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**************************************************</span><br><span class="line"> * Start</span><br><span class="line"> **************************************************/</span><br><span class="line"> </span><br><span class="line">static void usage() &#123;</span><br><span class="line">    printf(&quot;Usage:\n&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;Checking TRX file:\n&quot;);</span><br><span class="line">    printf(&quot;\totrx check &lt;file&gt; [options]\tcheck if file is a valid TRX\n&quot;);</span><br><span class="line">    printf(&quot;\t-o offset\t\t\toffset of TRX data in file (default: 0)\n&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;Creating new TRX file:\n&quot;);</span><br><span class="line">    printf(&quot;\totrx create &lt;file&gt; [options] [partitions]\n&quot;);</span><br><span class="line">    printf(&quot;\t-f file\t\t\t\t[partition] start new partition with content copied from file\n&quot;);</span><br><span class="line">    printf(&quot;\t-A file\t\t\t\t[partition] append current partition with content copied from file\n&quot;);</span><br><span class="line">    printf(&quot;\t-a alignment\t\t\t[partition] align current partition\n&quot;);</span><br><span class="line">    printf(&quot;\t-b offset\t\t\t[partition] append zeros to partition till reaching absolute offset\n&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;Extracting from TRX file:\n&quot;);</span><br><span class="line">    printf(&quot;\totrx extract &lt;file&gt; [options]\textract partitions from TRX file\n&quot;);</span><br><span class="line">    printf(&quot;\t-o offset\t\t\toffset of TRX data in file (default: 0)\n&quot;);</span><br><span class="line">    printf(&quot;\t-1 file\t\t\t\tfile to extract 1st partition to (optional)\n&quot;);</span><br><span class="line">    printf(&quot;\t-2 file\t\t\t\tfile to extract 2nd partition to (optional)\n&quot;);</span><br><span class="line">    printf(&quot;\t-3 file\t\t\t\tfile to extract 3rd partition to (optional)\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        if (!strcmp(argv[1], &quot;check&quot;))</span><br><span class="line">            return otrx_check(argc, argv);</span><br><span class="line">        else if (!strcmp(argv[1], &quot;create&quot;))</span><br><span class="line">            return otrx_create(argc, argv);</span><br><span class="line">        else if (!strcmp(argv[1], &quot;extract&quot;))</span><br><span class="line">            return otrx_extract(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    usage();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Makefile （位于/home/openwrt/package/example/src 目录下面）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all: myapp</span><br><span class="line"> </span><br><span class="line">myapp:</span><br><span class="line">    $(CC) $(CFLAGS) -o $@ myapp.c -Wall</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">    rm -f myapp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Makefile（位于/home/openwrt/package/example/ 目录下面）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is free software, licensed under the GNU General Public License v2.</span><br><span class="line"># See /LICENSE for more information.</span><br><span class="line">#</span><br><span class="line"> </span><br><span class="line">include $(TOPDIR)/rules.mk</span><br><span class="line"> </span><br><span class="line">PKG_NAME:=myapp</span><br><span class="line">PKG_RELEASE:=1</span><br><span class="line"> </span><br><span class="line">PKG_FLAGS:=nonshared</span><br><span class="line"> </span><br><span class="line">include $(INCLUDE_DIR)/package.mk</span><br><span class="line"> </span><br><span class="line">define Package/myapp</span><br><span class="line">  SECTION:=utils</span><br><span class="line">  CATEGORY:=Base system</span><br><span class="line">  TITLE:=This is my first app</span><br><span class="line">  MAINTAINER:=LuMingFeng &lt;forgotfun@qq.com&gt;</span><br><span class="line">endef</span><br><span class="line"> </span><br><span class="line">define Package/myapp/description</span><br><span class="line"> This package is my first package.</span><br><span class="line">endef</span><br><span class="line"> </span><br><span class="line">define Build/Compile</span><br><span class="line">    $(MAKE) -C $(PKG_BUILD_DIR) \</span><br><span class="line">        CC=&quot;$(TARGET_CC)&quot; \</span><br><span class="line">        CFLAGS=&quot;$(TARGET_CFLAGS) -Wall&quot;</span><br><span class="line">endef</span><br><span class="line"> </span><br><span class="line">define Package/myapp/install</span><br><span class="line">    $(CP) ./files/* $(1)/</span><br><span class="line">    $(INSTALL_DIR) $(1)/usr/bin</span><br><span class="line">    $(INSTALL_BIN) $(PKG_BUILD_DIR)/myapp $(1)/usr/bin/</span><br><span class="line">endef</span><br><span class="line"> </span><br><span class="line">$(eval $(call BuildPackage,myapp))</span><br></pre></td></tr></table></figure>
<p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w@w:/home/openwrt/package/example$ ls</span><br><span class="line">Makefile  src</span><br><span class="line">w@w:/home/openwrt/package/example/src$ ls</span><br><span class="line">Makefile  myapp.c</span><br></pre></td></tr></table></figure>
<h1 id="十七、固件的结构分析，逆向解包"><a href="#十七、固件的结构分析，逆向解包" class="headerlink" title="十七、固件的结构分析，逆向解包"></a>十七、固件的结构分析，逆向解包</h1><h2 id="gt-固件是由三部分组成：固件头、kernel、rootfs。我们可以通过mkimage工具分析固件头，用binwalk来解包固件分析kernel和rootfs，通常rootfs一般是squashfs格式的。下面我来一步步给大家剖析，每个部分的细节。"><a href="#gt-固件是由三部分组成：固件头、kernel、rootfs。我们可以通过mkimage工具分析固件头，用binwalk来解包固件分析kernel和rootfs，通常rootfs一般是squashfs格式的。下面我来一步步给大家剖析，每个部分的细节。" class="headerlink" title="&gt; 固件是由三部分组成：固件头、kernel、rootfs。我们可以通过mkimage工具分析固件头，用binwalk来解包固件分析kernel和rootfs，通常rootfs一般是squashfs格式的。下面我来一步步给大家剖析，每个部分的细节。"></a>&gt; 固件是由三部分组成：固件头、kernel、rootfs。我们可以通过mkimage工具分析固件头，用binwalk来解包固件分析kernel和rootfs，通常rootfs一般是squashfs格式的。下面我来一步步给大家剖析，每个部分的细节。</h2><ul>
<li><p>1- 固件头，用于让uboot可以识别固件，解压等非常关键的信息。</p>
</li>
<li><p>2- kernel</p>
</li>
<li><p>3- rootfs</p>
</li>
<li><p>4- 填充区（为了取整）</p>
</li>
</ul>
<p>BroadCom(博通)trx固件头定义（HDR0）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct trx_header &#123;</span><br><span class="line">    uint32_t magic;            /* &quot;HDR0&quot; */</span><br><span class="line">    uint32_t len;            /* Length of file including header */</span><br><span class="line">    uint32_t crc32;            /* 32-bit CRC from flag_version to end of file */</span><br><span class="line">    uint32_t flag_version;    /* 0:15 flags, 16:31 version */</span><br><span class="line">    uint32_t offsets[4];    /* Offsets of partitions from start of header */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>MediaTek(联发科)、QualCom(高通 )u-boot固件头定义<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define IH_MAGIC    0x27051956  /* Image Magic Number       */</span><br><span class="line">#define IH_NMLEN        32  /* Image Name Length        */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * Legacy format image header,</span><br><span class="line"> * all data in network byte order (aka natural aka bigendian).</span><br><span class="line"> */</span><br><span class="line">typedef struct image_header &#123;</span><br><span class="line">    uint32_t    ih_magic;   /* Image Header Magic Number    */</span><br><span class="line">    uint32_t    ih_hcrc;    /* Image Header CRC Checksum    */</span><br><span class="line">    uint32_t    ih_time;    /* Image Creation Timestamp */</span><br><span class="line">    uint32_t    ih_size;    /* Image Data Size      */</span><br><span class="line">    uint32_t    ih_load;    /* Data  Load  Address      */</span><br><span class="line">    uint32_t    ih_ep;      /* Entry Point Address      */</span><br><span class="line">    uint32_t    ih_dcrc;    /* Image Data CRC Checksum  */</span><br><span class="line">    uint8_t     ih_os;      /* Operating System     */</span><br><span class="line">    uint8_t     ih_arch;    /* CPU architecture     */</span><br><span class="line">    uint8_t     ih_type;    /* Image Type           */</span><br><span class="line">    uint8_t     ih_comp;    /* Compression Type     */</span><br><span class="line">    uint8_t     ih_name[IH_NMLEN];  /* Image Name       */</span><br><span class="line">&#125; image_header_t;</span><br></pre></td></tr></table></figure></p>
<p>其它固件头：TPLINK，NETGEAR等，防止固件版本误刷。</p>
<p>binwalk地址：<a target="_blank" rel="noopener" href="https://github.com/ForgotFun/binwalk">https://github.com/ForgotFun/binwalk</a> </p>
<p>Uboot固件头：0x27051956</p>
<p><img src="https://img-blog.csdnimg.cn/20210715222457917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715222804896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p><img src="https://img-blog.csdnimg.cn/20210715223247456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715223428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715223553624.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715223706119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715223755190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715223900905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"><br>如何用mksquashfs mkinage 将解压的image打包回去？</p>
<h1 id="十八、Cron定时任务"><a href="#十八、Cron定时任务" class="headerlink" title="十八、Cron定时任务"></a>十八、Cron定时任务</h1><blockquote>
<p>定时任务，比如：设定每天0点重启路由器，晚上11：00~早8：00关闭LED灯和Wifi，周一到周五关闭wifi等。 </p>
<p>OpenWrt计划任务服务默认是关闭的，启用cron需要启用cron服务。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/cron enable</span><br><span class="line">/etc/init.d/cron start</span><br></pre></td></tr></table></figure>
<ul>
<li>cron时间规则格式如何下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># ┌───────────── minute (0 - 59)</span><br><span class="line"># │ ┌───────────── hour (0 - 23)</span><br><span class="line"># │ │ ┌───────────── day of month (1 - 31)</span><br><span class="line"># │ │ │ ┌───────────── month (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday;7 is also Sunday on some systems)</span><br><span class="line"># │ │ │ │ │                                       </span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *  command to execute</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>*/5</th>
<th>*</th>
<th>*</th>
<th>*</th>
<th>*</th>
<th>every 5 minutes</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>*/3</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>every 3 hours at 12 minutes</td>
</tr>
<tr>
<td>57</td>
<td>11</td>
<td>15</td>
<td>1,6,12</td>
<td>*</td>
<td>At 11:57 Hrs  on 15th of Jan, June &amp; Dec.</td>
</tr>
<tr>
<td>25</td>
<td>6</td>
<td>*</td>
<td>*</td>
<td>1-5</td>
<td>At 6:25 AM every weekday (Mon-Fri)</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>4,12,26</td>
<td>*</td>
<td>*</td>
<td>At midnight on 4th, 12th and 26th of every month</td>
</tr>
<tr>
<td>5,10</td>
<td>9,14</td>
<td>10</td>
<td>*</td>
<td>0,4</td>
<td>At 9:05AM, 9:10AM, 2:05PM and 2:10PM every Sunday and Thursday</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 表示 所有</span><br><span class="line"></span><br><span class="line">- 表示 区间</span><br><span class="line"></span><br><span class="line">, 表示 或者</span><br><span class="line"></span><br><span class="line">/ 表示 步进</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*  表示任意</span><br><span class="line">-  表示范围</span><br><span class="line">,  表示枚举多个值</span><br><span class="line">/  表示每隔</span><br><span class="line"></span><br><span class="line">比如 0 0 * * * reboot 表示 0:0 重启路由器。</span><br><span class="line"></span><br><span class="line">0： 分钟</span><br><span class="line"></span><br><span class="line">0：小时</span><br><span class="line"></span><br><span class="line">* ： 日</span><br><span class="line"></span><br><span class="line">*： 月</span><br><span class="line"></span><br><span class="line">* ： 周几</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>reboot： 执行的命令。</p>
<p>周1~5 wifi down， 周六周日wifi up。 有的6/7表示周六周日，有点6/0表示周六周日 </p>
<p><img src="https://img-blog.csdnimg.cn/20210715152103573.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20210715153747761.png" alt="image"></p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-user/base-system/cron">https://openwrt.org/docs/guide-user/base-system/cron</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a></p>
<hr>
<h1 id="十九、开机自启动服务"><a href="#十九、开机自启动服务" class="headerlink" title="十九、开机自启动服务"></a>十九、开机自启动服务</h1><p>OpenWRT开机自启动服务通过procd来管理，ubuntu通过systemd管理</p>
<p>OpenWrt开机启动服务实现和普通Linux发行版并无明显差异，基本上就是/etc/init.d和/etc/rc.d两个目录在起关键作用。/etc/init.d目录存放的是所有的开机启动脚本（包含启动和未启用的服务），/etc/rc.d存放的是启用的（Enabled）开机启动脚本。只有enabled的service才可以通过软连接放到/etc/rc.d.</p>
<p>服务的启用和禁用可以通过service enable/disable命令来实现。</p>
<p>虽然通过/etc/rc.local脚本也可以实现创建开机启动脚本，但并不推荐。首先开机启动的顺序不可控、管理混乱、其次违背了openwrt service的规则。通常作为service通常需要具备start、stop、restart、enable、disable几大操作，rc.local仅仅提供了start的操作。假如我们把/etc/rc.local打包到package的话会导致管理混乱，rc.local是全局性的开机启动脚本并不属于某个package。 /etc/rc.local是最后被执行的，隶属于S95done。rc.local不适合放用户层面的文件<br><img src="https://img-blog.csdnimg.cn/20210716142958690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<ul>
<li>发现，在/etc/init.d与/etc/rc.d下面有相同的gpid_switch文件。<br><img src="https://img-blog.csdnimg.cn/20210716143347586.png" alt="image"></li>
</ul>
<p>用md5sum命令查看，发现这三个文件内容完全相同。<br><img src="https://img-blog.csdnimg.cn/2021071614344978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>用ls -al查看，发现K10gpio_switch 与 S94gpio_switch均通过软连接只想同一个 ../init.d/gpio_switch文件。 </p>
<p>软连命令 ln -s<br><img src="https://img-blog.csdnimg.cn/20210716143751482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>查看K10gpio_switch文件，发现文件开头有START=94，STOP=10，其中START=94<br><img src="https://img-blog.csdnimg.cn/20210716143920597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>查看S96led这个文件，发现只有START=96<br><img src="https://img-blog.csdnimg.cn/20210716144037703.png" alt="image"><br>每个服务都应该支持start，stop，restart(stop + sleep + start)，reload，enabe，disable等几个功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210716144311582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>disable /etc/init.d/gpio_switch服务，发现/etc/rc.d里面的S94gpio_switch与K10gpio_switch这两个服务已经不存在。</p>
<p><img src="https://img-blog.csdnimg.cn/20210716144534436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>enable /etc/init.d/gpio_switch服务，发现/etc/rc.d里面的S94gpio_switch与K10gpio_switch这两个服务再次出现。<br><img src="https://img-blog.csdnimg.cn/20210716144650268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p><img src="https://img-blog.csdnimg.cn/20210716144758236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2YyMTU3MTIw,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>案例：某T1E1卡设置iperf 对打，rc.local设置。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add link eth6 name eth6.102 type vlan id 102</span><br><span class="line">ip link add link eth6 name eth6.202 type vlan id 202</span><br><span class="line">ip link add link eth6 name eth6.302 type vlan id 302</span><br><span class="line">ip link add link eth6 name eth6.402 type vlan id 402</span><br><span class="line">ip link set eth6.102 address 00:a0:c9:00:00:01</span><br><span class="line">ip link set eth6.202 address 00:a0:c9:00:00:02</span><br><span class="line">ip link set eth6.302 address 00:a0:c9:00:00:03</span><br><span class="line">ip link set eth6.402 address 00:a0:c9:00:00:04</span><br><span class="line">ifconfig eth0 17.0.0.1 up</span><br><span class="line">ifconfig eth6 192.168.40.123 up</span><br><span class="line">ifconfig eth6.102 10.10.10.1 up</span><br><span class="line">ifconfig eth6.202 11.10.10.1 up</span><br><span class="line">ifconfig eth6.302 12.10.10.1 up</span><br><span class="line">ifconfig eth6.402 13.10.10.1 up</span><br><span class="line">route add -net 14.0.0.0 netmask 255.0.0.0 gw 13.10.10.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>对方平台<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add link eth6 name eth6.102 type vlan id 102</span><br><span class="line">ip link add link eth6 name eth6.202 type vlan id 202</span><br><span class="line">ip link add link eth6 name eth6.302 type vlan id 302</span><br><span class="line">ip link add link eth6 name eth6.402 type vlan id 402</span><br><span class="line">ip link set eth6.102 address 00:a0:c9:00:00:05</span><br><span class="line">ip link set eth6.202 address 00:a0:c9:00:00:06</span><br><span class="line">ip link set eth6.302 address 00:a0:c9:00:00:07</span><br><span class="line">ip link set eth6.402 address 00:a0:c9:00:00:08</span><br><span class="line">ifconfig eth0 14.0.0.1 up</span><br><span class="line">ifconfig eth6 192.168.40.122 up</span><br><span class="line">ifconfig eth6.102 10.10.10.2 up</span><br><span class="line">ifconfig eth6.202 11.10.10.2 up</span><br><span class="line">ifconfig eth6.302 12.10.10.2 up</span><br><span class="line">ifconfig eth6.402 13.10.10.2 up</span><br><span class="line">route add -net 17.0.0.0 netmask 255.0.0.0 gw 13.10.10.2</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二十、opkg特性应用实例-升级时保留配置文件、opkg-install-remove-时保留配置文件"><a href="#二十、opkg特性应用实例-升级时保留配置文件、opkg-install-remove-时保留配置文件" class="headerlink" title="二十、opkg特性应用实例(升级时保留配置文件、opkg install remove 时保留配置文件)"></a>二十、opkg特性应用实例(升级时保留配置文件、opkg install remove 时保留配置文件)</h1><p>preinstall/postnstall 安装app时，保留上一次的文件</p>
<p>如果升级后要保留config文件，一定要用sysupgrade升级</p>
<p>在uboot/cfe下升级，配置文件不会被保留</p>
<p>升级时保留配置文件由sysupgrade实现</p>
<p>opkg安装：会将前面的配置覆盖。 升级时备份之前的配置，升级后，恢复原来的配置，从而实现升级后保留之前的配置文件。</p>
<p>make package/example/compile V=99</p>
<p>多级makefile如何实现？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NPCS_AS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://alongsoft2018.github.io.git/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/">https://alongsoft2018.github.io.git/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/openwrt/">openwrt</a><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="https://openwrt.org/_media/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/npcs.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/npcs.jpeg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B031_45/"><img class="prev-cover" src="https://openwrt.org/_media/logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Openwrt学习笔记31_45</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_10/"><img class="next-cover" src="https://openwrt.org/_media/logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Openwrt学习笔记1_10</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/08/18/Openwrt学习笔记1_10/" title="Openwrt学习笔记1_10"><img class="cover" src="https://openwrt.org/_media/logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-18</div><div class="title">Openwrt学习笔记1_10</div></div></a></div><div><a href="/2021/08/18/Openwrt学习笔记21_30/" title="Openwrt学习笔记21_30"><img class="cover" src="https://openwrt.org/_media/logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-18</div><div class="title">Openwrt学习笔记21_30</div></div></a></div><div><a href="/2021/08/18/Openwrt学习笔记31_45/" title="Openwrt学习笔记31_45"><img class="cover" src="https://openwrt.org/_media/logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-18</div><div class="title">Openwrt学习笔记31_45</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar_max.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">NPCS_AS</div><div class="author-info__description">ABC</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81UCI"><span class="toc-number">1.</span> <span class="toc-text">十一、UCI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81OpenWRT%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">十二、OpenWRT启动过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">2.1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preinit"><span class="toc-number">2.2.</span> <span class="toc-text">preinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E6%89%A7%E8%A1%8C-etc-preinit"><span class="toc-number">2.3.</span> <span class="toc-text">再次执行 &#x2F;etc&#x2F;preinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#procd"><span class="toc-number">2.4.</span> <span class="toc-text">procd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STATE-EARLY"><span class="toc-number">2.5.</span> <span class="toc-text">STATE_EARLY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STATE-UBUS"><span class="toc-number">2.6.</span> <span class="toc-text">STATE_UBUS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STATE-INIT"><span class="toc-number">2.7.</span> <span class="toc-text">STATE_INIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STATE-RUNNING"><span class="toc-number">2.8.</span> <span class="toc-text">STATE_RUNNING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">2.9.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenWRT-LEDE-System-Boot-Sequence"><span class="toc-number">2.10.</span> <span class="toc-text">OpenWRT&#x2F;LEDE: System Boot Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Overview"><span class="toc-number">2.11.</span> <span class="toc-text">1. Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Preinit"><span class="toc-number">2.12.</span> <span class="toc-text">2. Preinit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-etc-preinit"><span class="toc-number">2.12.1.</span> <span class="toc-text">2.1 &#x2F;etc&#x2F;preinit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-sbin-init"><span class="toc-number">2.12.2.</span> <span class="toc-text">2.3 &#x2F;sbin&#x2F;init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-etc-preinit-again"><span class="toc-number">2.12.3.</span> <span class="toc-text">2.2 &#x2F;etc&#x2F;preinit again</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#At-last-etc-preinit-will-excute-boot-run-hook-to-find-and-excute-functions-hooked-at-certain-node-In-current-system-it-will-start-from-boot-run-hook-preinit-main"><span class="toc-number">2.13.</span> <span class="toc-text">At last &#x2F;etc&#x2F;preinit will excute boot_run_hook to find and excute functions hooked at certain node. In current system it will start from boot_run_hook preinit_main.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Watchdog"><span class="toc-number">2.13.1.</span> <span class="toc-text">3. Watchdog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#If-the-watchdog-dev-dev-watchdog-exists-setting-watchdog-timeout-as-30-second-If-the-Linux-kernel-doese-not-receive-any-data-the-system-will-be-rebooted-The-process-use-uloop-to-write-some-data-into-Linux-kernel-periodly-5s-which-indicates-that-the-process-is-woring-well"><span class="toc-number">2.14.</span> <span class="toc-text">If the watchdog dev &#x2F;dev&#x2F;watchdog exists, setting watchdog timeout as 30 second. If the Linux kernel doese not receive any data, the system will be rebooted. The process use uloop to write some data into Linux kernel periodly (5s), which indicates that the process is woring well.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-procd"><span class="toc-number">2.14.1.</span> <span class="toc-text">4. procd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-STATE-EARLY"><span class="toc-number">2.14.2.</span> <span class="toc-text">4.1 STATE_EARLY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-STATE-UBUS"><span class="toc-number">2.14.3.</span> <span class="toc-text">4.2 STATE_UBUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-STATE-INIT"><span class="toc-number">2.14.4.</span> <span class="toc-text">4.3 STATE_INIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-STATE-RUNNING"><span class="toc-number">2.14.5.</span> <span class="toc-text">4.4 STATE_RUNNING</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">2.15.</span> <span class="toc-text">References</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81ubus"><span class="toc-number">3.</span> <span class="toc-text">十三、ubus</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81hotplug%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">十四、hotplug机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81opkg-%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">十五、opkg 包管理机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E5%88%9B%E5%BB%BAOpenWrt-Package"><span class="toc-number">6.</span> <span class="toc-text">十六、创建OpenWrt Package</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%9B%BA%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%86%E5%90%91%E8%A7%A3%E5%8C%85"><span class="toc-number">7.</span> <span class="toc-text">十七、固件的结构分析，逆向解包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E5%9B%BA%E4%BB%B6%E6%98%AF%E7%94%B1%E4%B8%89%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9A%E5%9B%BA%E4%BB%B6%E5%A4%B4%E3%80%81kernel%E3%80%81rootfs%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87mkimage%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E5%9B%BA%E4%BB%B6%E5%A4%B4%EF%BC%8C%E7%94%A8binwalk%E6%9D%A5%E8%A7%A3%E5%8C%85%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90kernel%E5%92%8Crootfs%EF%BC%8C%E9%80%9A%E5%B8%B8rootfs%E4%B8%80%E8%88%AC%E6%98%AFsquashfs%E6%A0%BC%E5%BC%8F%E7%9A%84%E3%80%82%E4%B8%8B%E9%9D%A2%E6%88%91%E6%9D%A5%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%89%96%E6%9E%90%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%83%A8%E5%88%86%E7%9A%84%E7%BB%86%E8%8A%82%E3%80%82"><span class="toc-number">7.1.</span> <span class="toc-text">&gt; 固件是由三部分组成：固件头、kernel、rootfs。我们可以通过mkimage工具分析固件头，用binwalk来解包固件分析kernel和rootfs，通常rootfs一般是squashfs格式的。下面我来一步步给大家剖析，每个部分的细节。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81Cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">8.</span> <span class="toc-text">十八、Cron定时任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">9.</span> <span class="toc-text">十九、开机自启动服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81opkg%E7%89%B9%E6%80%A7%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E5%8D%87%E7%BA%A7%E6%97%B6%E4%BF%9D%E7%95%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81opkg-install-remove-%E6%97%B6%E4%BF%9D%E7%95%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">二十、opkg特性应用实例(升级时保留配置文件、opkg install remove 时保留配置文件)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B031_45/" title="Openwrt学习笔记31_45"><img src="https://openwrt.org/_media/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openwrt学习笔记31_45"/></a><div class="content"><a class="title" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B031_45/" title="Openwrt学习笔记31_45">Openwrt学习笔记31_45</a><time datetime="2021-08-17T17:41:22.000Z" title="Created 2021-08-18 01:41:22">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/" title="Openwrt学习笔记11_20"><img src="https://openwrt.org/_media/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openwrt学习笔记11_20"/></a><div class="content"><a class="title" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011_20/" title="Openwrt学习笔记11_20">Openwrt学习笔记11_20</a><time datetime="2021-08-17T17:36:22.000Z" title="Created 2021-08-18 01:36:22">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_10/" title="Openwrt学习笔记1_10"><img src="https://openwrt.org/_media/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openwrt学习笔记1_10"/></a><div class="content"><a class="title" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_10/" title="Openwrt学习笔记1_10">Openwrt学习笔记1_10</a><time datetime="2021-08-17T17:36:22.000Z" title="Created 2021-08-18 01:36:22">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B021_30/" title="Openwrt学习笔记21_30"><img src="https://openwrt.org/_media/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openwrt学习笔记21_30"/></a><div class="content"><a class="title" href="/2021/08/18/Openwrt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B021_30/" title="Openwrt学习笔记21_30">Openwrt学习笔记21_30</a><time datetime="2021-08-17T17:36:22.000Z" title="Created 2021-08-18 01:36:22">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Objection%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Objection使用学习笔记"><img src="https://image.winudf.com/v2/image1/Y29tLmF4Y29kZS5mcmlkYV9pY29uXzE1NDIwOTE0OTZfMDk5/icon.png?w=340&amp;fakeurl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Objection使用学习笔记"/></a><div class="content"><a class="title" href="/2021/08/13/Objection%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Objection使用学习笔记">Objection使用学习笔记</a><time datetime="2021-08-12T19:13:22.000Z" title="Created 2021-08-13 03:13:22">2021-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By NPCS_AS</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>